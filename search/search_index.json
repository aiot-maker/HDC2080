{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"HDC2080 Module We use a module manufactured by CJMCU which is designed around the Texas Instrument HDC2080 integrated circuit. Description The HDC2080 is a digital humidity and temperature sensor with some appealing features: High accuracy Low power consumption I2C interface Programmable thresholds Data Ready / Interruput pin Powering the module - 3.3V only The integrated circuit has a supply voltage range of 1.6V to 3.6V. The module doesn\u00b4t have a voltage regulator therefore it can only be powered by 3.3V. Pinout SDC SLA are the I2C pins GND , VCC are the power supply pins ADD , this input pin allows to select an alternative I2C bus address for the module. When disconnected or connected to GND the module will appear to the bus with 0x40 address. When this pin is connected to 3.3V the I2C address will be 0x41. INT , this output pin can be used to signal that a measurement is available in the registers or be used to signal temperature or humidity thresholds. CJMCU Module","title":"Module"},{"location":"#hdc2080","text":"","title":"HDC2080"},{"location":"#module","text":"We use a module manufactured by CJMCU which is designed around the Texas Instrument HDC2080 integrated circuit.","title":"Module"},{"location":"#description","text":"The HDC2080 is a digital humidity and temperature sensor with some appealing features: High accuracy Low power consumption I2C interface Programmable thresholds Data Ready / Interruput pin","title":"Description"},{"location":"#powering-the-module-33v-only","text":"The integrated circuit has a supply voltage range of 1.6V to 3.6V. The module doesn\u00b4t have a voltage regulator therefore it can only be powered by 3.3V.","title":"Powering the module - 3.3V only"},{"location":"#pinout","text":"SDC SLA are the I2C pins GND , VCC are the power supply pins ADD , this input pin allows to select an alternative I2C bus address for the module. When disconnected or connected to GND the module will appear to the bus with 0x40 address. When this pin is connected to 3.3V the I2C address will be 0x41. INT , this output pin can be used to signal that a measurement is available in the registers or be used to signal temperature or humidity thresholds. CJMCU Module","title":"Pinout"},{"location":"allflows/","text":"Putting it all together We have developed several small flows that allows read and right to the registers of the HDC2080. These flows allows us to use most of the features available in this awesome digital sensor. It is easy to use these flows as a starting point to build subflows that allow reading and writing to the device in a simpler way. This is however out of the scope of this tutorial. All flows: [{\"id\":\"ae40d2da42dfdbb2\",\"type\":\"tab\",\"label\":\"HDC2080\",\"disabled\":false,\"info\":\"\"},{\"id\":\"e207ea6471f306f4\",\"type\":\"inject\",\"z\":\"ae40d2da42dfdbb2\",\"name\":\"Click to run\",\"props\":[{\"p\":\"payload\"},{\"p\":\"topic\",\"vt\":\"str\"}],\"repeat\":\"\",\"crontab\":\"\",\"once\":false,\"onceDelay\":0.1,\"topic\":\"\",\"payloadType\":\"date\",\"x\":180,\"y\":140,\"wires\":[[\"2ca8939ae6b0ac08\"]]},{\"id\":\"8f852f4ea6291a5e\",\"type\":\"debug\",\"z\":\"ae40d2da42dfdbb2\",\"name\":\"Debug flow1\",\"active\":true,\"tosidebar\":true,\"console\":false,\"tostatus\":true,\"complete\":\"payload\",\"targetType\":\"msg\",\"statusVal\":\"payload\",\"statusType\":\"auto\",\"x\":650,\"y\":140,\"wires\":[]},{\"id\":\"3676564ac6445fe1\",\"type\":\"comment\",\"z\":\"ae40d2da42dfdbb2\",\"name\":\"Flow 1 : Read manufacturer ID\",\"info\":\"\",\"x\":220,\"y\":80,\"wires\":[]},{\"id\":\"2ca8939ae6b0ac08\",\"type\":\"function\",\"z\":\"ae40d2da42dfdbb2\",\"name\":\"Read manufacturer ID\",\"func\":\"const HDC2080_I2C = 0x40;\\n\\nconst hdc = i2c.openSync(1);\\nlet r = hdc.readWordSync(HDC2080_I2C, 0xFC);\\nhdc.closeSync();\\n\\nmsg.payload = `Manufacturer ID: 0x${r.toString(16)}`;\\nreturn msg;\",\"outputs\":1,\"noerr\":0,\"initialize\":\"\",\"finalize\":\"\",\"libs\":[{\"var\":\"i2c\",\"module\":\"i2c-bus\"}],\"x\":400,\"y\":140,\"wires\":[[\"8f852f4ea6291a5e\"]]},{\"id\":\"24d24b3f86e7d89a\",\"type\":\"function\",\"z\":\"ae40d2da42dfdbb2\",\"name\":\"Read configuration register\",\"func\":\"const HDC2080_I2C = 0x40;\\n\\nconst hdc = i2c.openSync(1);\\nlet r1 = hdc.readByteSync(HDC2080_I2C, 0x0E);\\nhdc.closeSync();\\n\\nmsg.payload = \\\"0x\\\" + r1.toString(16).padStart(2, '0');\\nreturn msg;\",\"outputs\":1,\"noerr\":0,\"initialize\":\"\",\"finalize\":\"\",\"libs\":[{\"var\":\"i2c\",\"module\":\"i2c-bus\"}],\"x\":420,\"y\":300,\"wires\":[[\"38ef03979f20bbe2\"]]},{\"id\":\"18e008a64c8ea4be\",\"type\":\"inject\",\"z\":\"ae40d2da42dfdbb2\",\"name\":\"Click to run\",\"props\":[{\"p\":\"payload\"},{\"p\":\"topic\",\"vt\":\"str\"}],\"repeat\":\"\",\"crontab\":\"\",\"once\":false,\"onceDelay\":0.1,\"topic\":\"\",\"payloadType\":\"date\",\"x\":180,\"y\":300,\"wires\":[[\"24d24b3f86e7d89a\"]]},{\"id\":\"e0fb19b67f1d56fd\",\"type\":\"comment\",\"z\":\"ae40d2da42dfdbb2\",\"name\":\"Flow 2 : Read configuration register 0x0E\",\"info\":\"\",\"x\":260,\"y\":240,\"wires\":[]},{\"id\":\"38ef03979f20bbe2\",\"type\":\"debug\",\"z\":\"ae40d2da42dfdbb2\",\"name\":\"Debug flow2\",\"active\":true,\"tosidebar\":true,\"console\":false,\"tostatus\":true,\"complete\":\"payload\",\"targetType\":\"msg\",\"statusVal\":\"payload\",\"statusType\":\"auto\",\"x\":650,\"y\":300,\"wires\":[]},{\"id\":\"2fce20d60bba3448\",\"type\":\"comment\",\"z\":\"ae40d2da42dfdbb2\",\"name\":\"Flow 2 : Write configuration register 0x0E\",\"info\":\"\",\"x\":260,\"y\":380,\"wires\":[]},{\"id\":\"3baa31a1db1fb78d\",\"type\":\"inject\",\"z\":\"ae40d2da42dfdbb2\",\"name\":\"Click to run\",\"props\":[{\"p\":\"payload\"},{\"p\":\"topic\",\"vt\":\"str\"}],\"repeat\":\"\",\"crontab\":\"\",\"once\":false,\"onceDelay\":0.1,\"topic\":\"\",\"payloadType\":\"date\",\"x\":180,\"y\":440,\"wires\":[[\"3be881cfad1c8e09\"]]},{\"id\":\"3be881cfad1c8e09\",\"type\":\"function\",\"z\":\"ae40d2da42dfdbb2\",\"name\":\"Write configuration register\",\"func\":\"const HDC2080_I2C = 0x40;\\n\\nconst hdc = i2c.openSync(1);\\nhdc.writeByteSync(HDC2080_I2C, 0x0E, 0x06);\\nhdc.closeSync();\\n\\nmsg.payload = \\\"0x06\\\";\\nreturn msg;\",\"outputs\":1,\"noerr\":0,\"initialize\":\"\",\"finalize\":\"\",\"libs\":[{\"var\":\"i2c\",\"module\":\"i2c-bus\"}],\"x\":420,\"y\":440,\"wires\":[[\"322d01ab7757eba2\"]]},{\"id\":\"322d01ab7757eba2\",\"type\":\"debug\",\"z\":\"ae40d2da42dfdbb2\",\"name\":\"Debug flow2\",\"active\":true,\"tosidebar\":true,\"console\":false,\"tostatus\":false,\"complete\":\"payload\",\"targetType\":\"msg\",\"statusVal\":\"\",\"statusType\":\"auto\",\"x\":650,\"y\":440,\"wires\":[]},{\"id\":\"45db449f2dcf4ce1\",\"type\":\"comment\",\"z\":\"ae40d2da42dfdbb2\",\"name\":\"Flow 3 : Trigger measurement via I2C\",\"info\":\"\",\"x\":250,\"y\":540,\"wires\":[]},{\"id\":\"4635f68954c0b4f8\",\"type\":\"inject\",\"z\":\"ae40d2da42dfdbb2\",\"name\":\"Click to run\",\"props\":[{\"p\":\"payload\"},{\"p\":\"topic\",\"vt\":\"str\"}],\"repeat\":\"\",\"crontab\":\"\",\"once\":false,\"onceDelay\":0.1,\"topic\":\"\",\"payloadType\":\"date\",\"x\":180,\"y\":600,\"wires\":[[\"c6c3eb7076945329\"]]},{\"id\":\"c6c3eb7076945329\",\"type\":\"function\",\"z\":\"ae40d2da42dfdbb2\",\"name\":\"Trigger measurement\",\"func\":\"const HDC2080_I2C = 0x40;\\n\\nconst hdc = i2c.openSync(1);\\nhdc.writeByteSync(HDC2080_I2C, 0x0F, 0x01);\\nhdc.closeSync();\\n\\nmsg.payload = \\\"Measurement triggered\\\";\\n\\nreturn msg;\",\"outputs\":1,\"noerr\":0,\"initialize\":\"\",\"finalize\":\"\",\"libs\":[{\"var\":\"i2c\",\"module\":\"i2c-bus\"}],\"x\":410,\"y\":600,\"wires\":[[\"133fd4465ffca89a\"]]},{\"id\":\"133fd4465ffca89a\",\"type\":\"debug\",\"z\":\"ae40d2da42dfdbb2\",\"name\":\"Debug flow3\",\"active\":true,\"tosidebar\":true,\"console\":false,\"tostatus\":false,\"complete\":\"payload\",\"targetType\":\"msg\",\"statusVal\":\"\",\"statusType\":\"auto\",\"x\":650,\"y\":600,\"wires\":[]},{\"id\":\"48d7c05adb4a40de\",\"type\":\"comment\",\"z\":\"ae40d2da42dfdbb2\",\"name\":\"Flow 4 : Read temperature\",\"info\":\"\",\"x\":210,\"y\":700,\"wires\":[]},{\"id\":\"219d5a07b5b3d622\",\"type\":\"inject\",\"z\":\"ae40d2da42dfdbb2\",\"name\":\"Click to run\",\"props\":[{\"p\":\"payload\"},{\"p\":\"topic\",\"vt\":\"str\"}],\"repeat\":\"\",\"crontab\":\"\",\"once\":false,\"onceDelay\":0.1,\"topic\":\"\",\"payloadType\":\"date\",\"x\":180,\"y\":760,\"wires\":[[\"ab3d99f63335f7f8\"]]},{\"id\":\"ab3d99f63335f7f8\",\"type\":\"function\",\"z\":\"ae40d2da42dfdbb2\",\"name\":\"Read temperature\",\"func\":\"const HDC2080_I2C = 0x40;\\n\\nlet hdc = i2c.openSync(1);\\nlet r = hdc.readWordSync(HDC2080_I2C, 0x00);\\nhdc.closeSync();\\n\\nmsg.payload = (r / 65536) * 165 - 40.5;\\n\\nreturn msg;\",\"outputs\":1,\"noerr\":0,\"initialize\":\"\",\"finalize\":\"\",\"libs\":[{\"var\":\"i2c\",\"module\":\"i2c-bus\"}],\"x\":370,\"y\":760,\"wires\":[[\"d3cf046c0705ecb6\"]]},{\"id\":\"d3cf046c0705ecb6\",\"type\":\"debug\",\"z\":\"ae40d2da42dfdbb2\",\"name\":\"Debug flow4\",\"active\":true,\"tosidebar\":true,\"console\":false,\"tostatus\":false,\"complete\":\"payload\",\"targetType\":\"msg\",\"statusVal\":\"\",\"statusType\":\"auto\",\"x\":570,\"y\":760,\"wires\":[]},{\"id\":\"3c8ea04b57908649\",\"type\":\"inject\",\"z\":\"ae40d2da42dfdbb2\",\"name\":\"Click to run\",\"props\":[{\"p\":\"payload\"},{\"p\":\"topic\",\"vt\":\"str\"}],\"repeat\":\"\",\"crontab\":\"\",\"once\":false,\"onceDelay\":0.1,\"topic\":\"\",\"payloadType\":\"date\",\"x\":180,\"y\":920,\"wires\":[[\"4875a12e866cb662\"]]},{\"id\":\"5e30deb66330b5d9\",\"type\":\"comment\",\"z\":\"ae40d2da42dfdbb2\",\"name\":\"Flow4 : Read Humidity\",\"info\":\"\",\"x\":200,\"y\":860,\"wires\":[]},{\"id\":\"4875a12e866cb662\",\"type\":\"function\",\"z\":\"ae40d2da42dfdbb2\",\"name\":\"Read humidity\",\"func\":\"const HDC2080_I2C = 0x40;\\n\\nlet hdc = i2c.openSync(1);\\nlet r = hdc.readWordSync(HDC2080_I2C, 0x02);\\nhdc.closeSync();\\n\\nmsg.payload = r / 65536 * 100;\\n\\nreturn msg;\",\"outputs\":1,\"noerr\":0,\"initialize\":\"\",\"finalize\":\"\",\"libs\":[{\"var\":\"i2c\",\"module\":\"i2c-bus\"}],\"x\":360,\"y\":920,\"wires\":[[\"1cec6607f73c9622\"]]},{\"id\":\"1cec6607f73c9622\",\"type\":\"debug\",\"z\":\"ae40d2da42dfdbb2\",\"name\":\"Debug flow4\",\"active\":true,\"tosidebar\":true,\"console\":false,\"tostatus\":false,\"complete\":\"payload\",\"targetType\":\"msg\",\"statusVal\":\"\",\"statusType\":\"auto\",\"x\":570,\"y\":920,\"wires\":[]},{\"id\":\"66512f3e1e0938dc\",\"type\":\"comment\",\"z\":\"ae40d2da42dfdbb2\",\"name\":\"Flow 5 : Read MAX temperature\",\"info\":\"\",\"x\":230,\"y\":1020,\"wires\":[]},{\"id\":\"139778360202aca7\",\"type\":\"inject\",\"z\":\"ae40d2da42dfdbb2\",\"name\":\"Click to run\",\"props\":[{\"p\":\"payload\"},{\"p\":\"topic\",\"vt\":\"str\"}],\"repeat\":\"\",\"crontab\":\"\",\"once\":false,\"onceDelay\":0.1,\"topic\":\"\",\"payloadType\":\"date\",\"x\":180,\"y\":1080,\"wires\":[[\"e4bf6d56a2d1a00f\"]]},{\"id\":\"e4bf6d56a2d1a00f\",\"type\":\"function\",\"z\":\"ae40d2da42dfdbb2\",\"name\":\"Read MAX temperature\",\"func\":\"const HDC2080_I2C = 0x40;\\n\\nconst hdc = i2c.openSync(1);\\nlet r1 = hdc.readByteSync(HDC2080_I2C, 0x05);\\nhdc.closeSync();\\n\\nmsg.payload = (r1 / 256) * 165 - 40.5;\\nreturn msg;\",\"outputs\":1,\"noerr\":0,\"initialize\":\"\",\"finalize\":\"\",\"libs\":[{\"var\":\"i2c\",\"module\":\"i2c-bus\"}],\"x\":390,\"y\":1080,\"wires\":[[\"5f66699f757577b8\"]]},{\"id\":\"5f66699f757577b8\",\"type\":\"debug\",\"z\":\"ae40d2da42dfdbb2\",\"name\":\"Debug flow5\",\"active\":true,\"tosidebar\":true,\"console\":false,\"tostatus\":false,\"complete\":\"payload\",\"targetType\":\"msg\",\"statusVal\":\"\",\"statusType\":\"auto\",\"x\":610,\"y\":1080,\"wires\":[]},{\"id\":\"7acf3202ed2f34ac\",\"type\":\"comment\",\"z\":\"ae40d2da42dfdbb2\",\"name\":\"Flow 5 : Read MAX humidity\",\"info\":\"\",\"x\":220,\"y\":1180,\"wires\":[]},{\"id\":\"cd2f739e240a486b\",\"type\":\"inject\",\"z\":\"ae40d2da42dfdbb2\",\"name\":\"Click to run\",\"props\":[{\"p\":\"payload\"},{\"p\":\"topic\",\"vt\":\"str\"}],\"repeat\":\"\",\"crontab\":\"\",\"once\":false,\"onceDelay\":0.1,\"topic\":\"\",\"payloadType\":\"date\",\"x\":180,\"y\":1240,\"wires\":[[\"9ab0e0e884823fc5\"]]},{\"id\":\"9ab0e0e884823fc5\",\"type\":\"function\",\"z\":\"ae40d2da42dfdbb2\",\"name\":\"Read MAX humidity\",\"func\":\"const HDC2080_I2C = 0x40;\\n\\nconst hdc = i2c.openSync(1);\\nlet r1 = hdc.readByteSync(HDC2080_I2C, 0x06);\\nhdc.closeSync();\\n\\nmsg.payload = (r1 / 256) * 100;\\n\\nreturn msg;\",\"outputs\":1,\"noerr\":0,\"initialize\":\"\",\"finalize\":\"\",\"libs\":[{\"var\":\"i2c\",\"module\":\"i2c-bus\"}],\"x\":380,\"y\":1240,\"wires\":[[\"0f5aca8fc8b1f7a2\"]]},{\"id\":\"0f5aca8fc8b1f7a2\",\"type\":\"debug\",\"z\":\"ae40d2da42dfdbb2\",\"name\":\"Debug flow5\",\"active\":true,\"tosidebar\":true,\"console\":false,\"tostatus\":false,\"complete\":\"payload\",\"targetType\":\"msg\",\"statusVal\":\"\",\"statusType\":\"auto\",\"x\":610,\"y\":1240,\"wires\":[]},{\"id\":\"53fbefa876532be8\",\"type\":\"comment\",\"z\":\"ae40d2da42dfdbb2\",\"name\":\"Flow 6 : Soft reset\",\"info\":\"\",\"x\":190,\"y\":1360,\"wires\":[]},{\"id\":\"aa6dd67bf670c943\",\"type\":\"inject\",\"z\":\"ae40d2da42dfdbb2\",\"name\":\"Click to run\",\"props\":[{\"p\":\"payload\"},{\"p\":\"topic\",\"vt\":\"str\"}],\"repeat\":\"\",\"crontab\":\"\",\"once\":false,\"onceDelay\":0.1,\"topic\":\"\",\"payloadType\":\"date\",\"x\":180,\"y\":1420,\"wires\":[[\"3a16126dc33f9eb1\"]]},{\"id\":\"3a16126dc33f9eb1\",\"type\":\"function\",\"z\":\"ae40d2da42dfdbb2\",\"name\":\"Soft reset\",\"func\":\"const HDC2080_I2C = 0x40;\\n\\nconst hdc = i2c.openSync(1);\\nlet r1 = hdc.readByteSync(HDC2080_I2C, 0x0E);\\nhdc.writeByteSync(HDC2080_I2C, 0x0E, 0x80);\\nhdc.closeSync();\\n\\nconst hdc1 = i2c.openSync(1);\\nhdc1.writeByteSync(HDC2080_I2C, 0x0E, r1);\\nhdc1.closeSync();\\n\\nmsg.payload = \\\"0x\\\" + r1.toString(16).padStart(2, '0');\\nreturn msg;\",\"outputs\":1,\"noerr\":0,\"initialize\":\"\",\"finalize\":\"\",\"libs\":[{\"var\":\"i2c\",\"module\":\"i2c-bus\"}],\"x\":340,\"y\":1420,\"wires\":[[\"9e5323c9ae142a3e\"]]},{\"id\":\"9e5323c9ae142a3e\",\"type\":\"debug\",\"z\":\"ae40d2da42dfdbb2\",\"name\":\"Debug flow6\",\"active\":true,\"tosidebar\":true,\"console\":false,\"tostatus\":false,\"complete\":\"payload\",\"targetType\":\"msg\",\"statusVal\":\"\",\"statusType\":\"auto\",\"x\":510,\"y\":1420,\"wires\":[]},{\"id\":\"96b572ada0aa82ba\",\"type\":\"comment\",\"z\":\"ae40d2da42dfdbb2\",\"name\":\"Flow 7 : Read the interrupt enable register\",\"info\":\"\",\"x\":260,\"y\":1500,\"wires\":[]},{\"id\":\"b1b6eaaeb69dd864\",\"type\":\"inject\",\"z\":\"ae40d2da42dfdbb2\",\"name\":\"Click to run\",\"props\":[{\"p\":\"payload\"},{\"p\":\"topic\",\"vt\":\"str\"}],\"repeat\":\"\",\"crontab\":\"\",\"once\":false,\"onceDelay\":0.1,\"topic\":\"\",\"payloadType\":\"date\",\"x\":180,\"y\":1560,\"wires\":[[\"afc545b7f11c3b0d\"]]},{\"id\":\"afc545b7f11c3b0d\",\"type\":\"function\",\"z\":\"ae40d2da42dfdbb2\",\"name\":\"Read interrupt enable register\",\"func\":\"const HDC2080_I2C = 0x40;\\n\\nconst hdc = i2c.openSync(1);\\nlet r1 = hdc.readByteSync(HDC2080_I2C, 0x07);\\nhdc.closeSync();\\n\\nmsg.payload = \\\"0x\\\" + r1.toString(16).padStart(2, '0');\\nreturn msg;\",\"outputs\":1,\"noerr\":0,\"initialize\":\"\",\"finalize\":\"\",\"libs\":[{\"var\":\"i2c\",\"module\":\"i2c-bus\"}],\"x\":410,\"y\":1560,\"wires\":[[\"6ed64a45ebcf5635\"]]},{\"id\":\"6ed64a45ebcf5635\",\"type\":\"debug\",\"z\":\"ae40d2da42dfdbb2\",\"name\":\"Debug flow7\",\"active\":true,\"tosidebar\":true,\"console\":false,\"tostatus\":false,\"complete\":\"payload\",\"targetType\":\"msg\",\"statusVal\":\"\",\"statusType\":\"auto\",\"x\":640,\"y\":1560,\"wires\":[]},{\"id\":\"5b6c3e16bba31549\",\"type\":\"inject\",\"z\":\"ae40d2da42dfdbb2\",\"name\":\"Click to run\",\"props\":[{\"p\":\"payload\"},{\"p\":\"topic\",\"vt\":\"str\"}],\"repeat\":\"\",\"crontab\":\"\",\"once\":false,\"onceDelay\":0.1,\"topic\":\"\",\"payloadType\":\"date\",\"x\":180,\"y\":1740,\"wires\":[[\"cc0c715c69b9385f\"]]},{\"id\":\"773cc86a0a24624a\",\"type\":\"comment\",\"z\":\"ae40d2da42dfdbb2\",\"name\":\"Flow 7 : Write value 0x80 to interrupt enable register\",\"info\":\"\",\"x\":290,\"y\":1680,\"wires\":[]},{\"id\":\"cc0c715c69b9385f\",\"type\":\"function\",\"z\":\"ae40d2da42dfdbb2\",\"name\":\"Write interrupt enable register\",\"func\":\"const HDC2080_I2C = 0x40;\\n\\nconst hdc = i2c.openSync(1);\\nhdc.writeByteSync(HDC2080_I2C, 0x07, 0x80);\\nhdc.closeSync();\\n\\nmsg.payload = \\\"0x80\\\";\\nreturn msg;\",\"outputs\":1,\"noerr\":0,\"initialize\":\"\",\"finalize\":\"\",\"libs\":[{\"var\":\"i2c\",\"module\":\"i2c-bus\"}],\"x\":410,\"y\":1740,\"wires\":[[\"9b9077d8f2270c52\"]]},{\"id\":\"9b9077d8f2270c52\",\"type\":\"debug\",\"z\":\"ae40d2da42dfdbb2\",\"name\":\"Debug flow7\",\"active\":true,\"tosidebar\":true,\"console\":false,\"tostatus\":false,\"complete\":\"payload\",\"targetType\":\"msg\",\"statusVal\":\"\",\"statusType\":\"auto\",\"x\":650,\"y\":1740,\"wires\":[]},{\"id\":\"1ad9ad6943e71d10\",\"type\":\"rpi-gpio in\",\"z\":\"ae40d2da42dfdbb2\",\"name\":\"\",\"pin\":\"11\",\"intype\":\"tri\",\"debounce\":\"0\",\"read\":false,\"x\":150,\"y\":1920,\"wires\":[[\"54ed70b77d532554\"]]},{\"id\":\"54ed70b77d532554\",\"type\":\"debug\",\"z\":\"ae40d2da42dfdbb2\",\"name\":\"PIN - GPIO17 - PIN 11 \",\"active\":true,\"tosidebar\":true,\"console\":false,\"tostatus\":false,\"complete\":\"payload\",\"targetType\":\"msg\",\"statusVal\":\"\",\"statusType\":\"auto\",\"x\":360,\"y\":1920,\"wires\":[]},{\"id\":\"8905e7dc3b52d696\",\"type\":\"comment\",\"z\":\"ae40d2da42dfdbb2\",\"name\":\"GPIO17 = PIN 11\",\"info\":\"\",\"x\":180,\"y\":1880,\"wires\":[]},{\"id\":\"fced05ac8073f868\",\"type\":\"comment\",\"z\":\"ae40d2da42dfdbb2\",\"name\":\"Flow 8 : 1 reading every 10 seconds\",\"info\":\"\",\"x\":240,\"y\":2040,\"wires\":[]},{\"id\":\"5c8a65ea991b187c\",\"type\":\"inject\",\"z\":\"ae40d2da42dfdbb2\",\"name\":\"Click to run\",\"props\":[{\"p\":\"payload\"},{\"p\":\"topic\",\"vt\":\"str\"}],\"repeat\":\"\",\"crontab\":\"\",\"once\":false,\"onceDelay\":0.1,\"topic\":\"\",\"payloadType\":\"date\",\"x\":180,\"y\":2100,\"wires\":[[\"b01133b39caa746c\"]]},{\"id\":\"b01133b39caa746c\",\"type\":\"function\",\"z\":\"ae40d2da42dfdbb2\",\"name\":\"1 reading every 10 seconds\",\"func\":\"const HDC2080_I2C = 0x40;\\n\\nconst hdc = i2c.openSync(1);\\nhdc.writeByteSync(HDC2080_I2C, 0x0E, 0x36);\\nhdc.closeSync();\\n\\nmsg.payload = \\\"0x36\\\";\\nreturn msg;\",\"outputs\":1,\"noerr\":0,\"initialize\":\"\",\"finalize\":\"\",\"libs\":[{\"var\":\"i2c\",\"module\":\"i2c-bus\"}],\"x\":400,\"y\":2100,\"wires\":[[\"020cd089a072125c\"]]},{\"id\":\"020cd089a072125c\",\"type\":\"debug\",\"z\":\"ae40d2da42dfdbb2\",\"name\":\"Debuf flow8\",\"active\":true,\"tosidebar\":true,\"console\":false,\"tostatus\":false,\"complete\":\"payload\",\"targetType\":\"msg\",\"statusVal\":\"\",\"statusType\":\"auto\",\"x\":630,\"y\":2100,\"wires\":[]},{\"id\":\"ce2acd20c5ad696e\",\"type\":\"comment\",\"z\":\"ae40d2da42dfdbb2\",\"name\":\"Flow 9 : Playing with the heater - 1 sample every 5 seconds\",\"info\":\"\",\"x\":320,\"y\":2220,\"wires\":[]},{\"id\":\"e3b67be803fb22e1\",\"type\":\"inject\",\"z\":\"ae40d2da42dfdbb2\",\"name\":\"Click to heat\",\"props\":[{\"p\":\"payload\"},{\"p\":\"topic\",\"vt\":\"str\"}],\"repeat\":\"\",\"crontab\":\"\",\"once\":false,\"onceDelay\":0.1,\"topic\":\"\",\"payloadType\":\"date\",\"x\":210,\"y\":2300,\"wires\":[[\"fc763414380a8a97\"]]},{\"id\":\"fc763414380a8a97\",\"type\":\"function\",\"z\":\"ae40d2da42dfdbb2\",\"name\":\"Heater ON - 0x4E\",\"func\":\"const HDC2080_I2C = 0x40;\\n\\nconst hdc = i2c.openSync(1);\\nhdc.writeByteSync(HDC2080_I2C, 0x0E, 0x4E);\\nhdc.closeSync();\\n\\nmsg.payload = \\\"The heater is ON - Check temperature register\\\";\\nreturn msg;\",\"outputs\":1,\"noerr\":0,\"initialize\":\"\",\"finalize\":\"\",\"libs\":[{\"var\":\"i2c\",\"module\":\"i2c-bus\"}],\"x\":400,\"y\":2300,\"wires\":[[\"069f453717167d28\",\"36d0ce4a604bab1c\"]]},{\"id\":\"538a3ccd51affbb3\",\"type\":\"function\",\"z\":\"ae40d2da42dfdbb2\",\"name\":\"Heater OFF - 0x46\",\"func\":\"const HDC2080_I2C = 0x40;\\n\\nconst hdc = i2c.openSync(1);\\nhdc.writeByteSync(HDC2080_I2C, 0x0E, 0x46);\\nhdc.closeSync();\\n\\nmsg.payload = \\\"The heater is OFF\\\";\\nreturn msg;\",\"outputs\":1,\"noerr\":0,\"initialize\":\"\",\"finalize\":\"\",\"libs\":[{\"var\":\"i2c\",\"module\":\"i2c-bus\"}],\"x\":570,\"y\":2420,\"wires\":[[\"8b003c2060dbda78\"]]},{\"id\":\"6e7c00ad4c07de04\",\"type\":\"inject\",\"z\":\"ae40d2da42dfdbb2\",\"name\":\"Click to cool off\",\"props\":[{\"p\":\"payload\"},{\"p\":\"topic\",\"vt\":\"str\"}],\"repeat\":\"\",\"crontab\":\"\",\"once\":false,\"onceDelay\":0.1,\"topic\":\"\",\"payloadType\":\"date\",\"x\":220,\"y\":2420,\"wires\":[[\"538a3ccd51affbb3\"]]},{\"id\":\"069f453717167d28\",\"type\":\"debug\",\"z\":\"ae40d2da42dfdbb2\",\"name\":\"Debug Flow9\",\"active\":true,\"tosidebar\":true,\"console\":false,\"tostatus\":false,\"complete\":\"payload\",\"targetType\":\"msg\",\"statusVal\":\"\",\"statusType\":\"auto\",\"x\":670,\"y\":2300,\"wires\":[]},{\"id\":\"8b003c2060dbda78\",\"type\":\"debug\",\"z\":\"ae40d2da42dfdbb2\",\"name\":\"Debug Flow9\",\"active\":true,\"tosidebar\":true,\"console\":false,\"tostatus\":false,\"complete\":\"payload\",\"targetType\":\"msg\",\"statusVal\":\"\",\"statusType\":\"auto\",\"x\":770,\"y\":2420,\"wires\":[]},{\"id\":\"36d0ce4a604bab1c\",\"type\":\"delay\",\"z\":\"ae40d2da42dfdbb2\",\"name\":\"\",\"pauseType\":\"delay\",\"timeout\":\"12\",\"timeoutUnits\":\"seconds\",\"rate\":\"1\",\"nbRateUnits\":\"1\",\"rateUnits\":\"second\",\"randomFirst\":\"1\",\"randomLast\":\"5\",\"randomUnits\":\"seconds\",\"drop\":false,\"allowrate\":false,\"x\":490,\"y\":2360,\"wires\":[[\"538a3ccd51affbb3\"]]}]","title":"Putting it all together"},{"location":"allflows/#putting-it-all-together","text":"We have developed several small flows that allows read and right to the registers of the HDC2080. These flows allows us to use most of the features available in this awesome digital sensor. It is easy to use these flows as a starting point to build subflows that allow reading and writing to the device in a simpler way. This is however out of the scope of this tutorial. All flows: [{\"id\":\"ae40d2da42dfdbb2\",\"type\":\"tab\",\"label\":\"HDC2080\",\"disabled\":false,\"info\":\"\"},{\"id\":\"e207ea6471f306f4\",\"type\":\"inject\",\"z\":\"ae40d2da42dfdbb2\",\"name\":\"Click to run\",\"props\":[{\"p\":\"payload\"},{\"p\":\"topic\",\"vt\":\"str\"}],\"repeat\":\"\",\"crontab\":\"\",\"once\":false,\"onceDelay\":0.1,\"topic\":\"\",\"payloadType\":\"date\",\"x\":180,\"y\":140,\"wires\":[[\"2ca8939ae6b0ac08\"]]},{\"id\":\"8f852f4ea6291a5e\",\"type\":\"debug\",\"z\":\"ae40d2da42dfdbb2\",\"name\":\"Debug flow1\",\"active\":true,\"tosidebar\":true,\"console\":false,\"tostatus\":true,\"complete\":\"payload\",\"targetType\":\"msg\",\"statusVal\":\"payload\",\"statusType\":\"auto\",\"x\":650,\"y\":140,\"wires\":[]},{\"id\":\"3676564ac6445fe1\",\"type\":\"comment\",\"z\":\"ae40d2da42dfdbb2\",\"name\":\"Flow 1 : Read manufacturer ID\",\"info\":\"\",\"x\":220,\"y\":80,\"wires\":[]},{\"id\":\"2ca8939ae6b0ac08\",\"type\":\"function\",\"z\":\"ae40d2da42dfdbb2\",\"name\":\"Read manufacturer ID\",\"func\":\"const HDC2080_I2C = 0x40;\\n\\nconst hdc = i2c.openSync(1);\\nlet r = hdc.readWordSync(HDC2080_I2C, 0xFC);\\nhdc.closeSync();\\n\\nmsg.payload = `Manufacturer ID: 0x${r.toString(16)}`;\\nreturn msg;\",\"outputs\":1,\"noerr\":0,\"initialize\":\"\",\"finalize\":\"\",\"libs\":[{\"var\":\"i2c\",\"module\":\"i2c-bus\"}],\"x\":400,\"y\":140,\"wires\":[[\"8f852f4ea6291a5e\"]]},{\"id\":\"24d24b3f86e7d89a\",\"type\":\"function\",\"z\":\"ae40d2da42dfdbb2\",\"name\":\"Read configuration register\",\"func\":\"const HDC2080_I2C = 0x40;\\n\\nconst hdc = i2c.openSync(1);\\nlet r1 = hdc.readByteSync(HDC2080_I2C, 0x0E);\\nhdc.closeSync();\\n\\nmsg.payload = \\\"0x\\\" + r1.toString(16).padStart(2, '0');\\nreturn msg;\",\"outputs\":1,\"noerr\":0,\"initialize\":\"\",\"finalize\":\"\",\"libs\":[{\"var\":\"i2c\",\"module\":\"i2c-bus\"}],\"x\":420,\"y\":300,\"wires\":[[\"38ef03979f20bbe2\"]]},{\"id\":\"18e008a64c8ea4be\",\"type\":\"inject\",\"z\":\"ae40d2da42dfdbb2\",\"name\":\"Click to run\",\"props\":[{\"p\":\"payload\"},{\"p\":\"topic\",\"vt\":\"str\"}],\"repeat\":\"\",\"crontab\":\"\",\"once\":false,\"onceDelay\":0.1,\"topic\":\"\",\"payloadType\":\"date\",\"x\":180,\"y\":300,\"wires\":[[\"24d24b3f86e7d89a\"]]},{\"id\":\"e0fb19b67f1d56fd\",\"type\":\"comment\",\"z\":\"ae40d2da42dfdbb2\",\"name\":\"Flow 2 : Read configuration register 0x0E\",\"info\":\"\",\"x\":260,\"y\":240,\"wires\":[]},{\"id\":\"38ef03979f20bbe2\",\"type\":\"debug\",\"z\":\"ae40d2da42dfdbb2\",\"name\":\"Debug flow2\",\"active\":true,\"tosidebar\":true,\"console\":false,\"tostatus\":true,\"complete\":\"payload\",\"targetType\":\"msg\",\"statusVal\":\"payload\",\"statusType\":\"auto\",\"x\":650,\"y\":300,\"wires\":[]},{\"id\":\"2fce20d60bba3448\",\"type\":\"comment\",\"z\":\"ae40d2da42dfdbb2\",\"name\":\"Flow 2 : Write configuration register 0x0E\",\"info\":\"\",\"x\":260,\"y\":380,\"wires\":[]},{\"id\":\"3baa31a1db1fb78d\",\"type\":\"inject\",\"z\":\"ae40d2da42dfdbb2\",\"name\":\"Click to run\",\"props\":[{\"p\":\"payload\"},{\"p\":\"topic\",\"vt\":\"str\"}],\"repeat\":\"\",\"crontab\":\"\",\"once\":false,\"onceDelay\":0.1,\"topic\":\"\",\"payloadType\":\"date\",\"x\":180,\"y\":440,\"wires\":[[\"3be881cfad1c8e09\"]]},{\"id\":\"3be881cfad1c8e09\",\"type\":\"function\",\"z\":\"ae40d2da42dfdbb2\",\"name\":\"Write configuration register\",\"func\":\"const HDC2080_I2C = 0x40;\\n\\nconst hdc = i2c.openSync(1);\\nhdc.writeByteSync(HDC2080_I2C, 0x0E, 0x06);\\nhdc.closeSync();\\n\\nmsg.payload = \\\"0x06\\\";\\nreturn msg;\",\"outputs\":1,\"noerr\":0,\"initialize\":\"\",\"finalize\":\"\",\"libs\":[{\"var\":\"i2c\",\"module\":\"i2c-bus\"}],\"x\":420,\"y\":440,\"wires\":[[\"322d01ab7757eba2\"]]},{\"id\":\"322d01ab7757eba2\",\"type\":\"debug\",\"z\":\"ae40d2da42dfdbb2\",\"name\":\"Debug flow2\",\"active\":true,\"tosidebar\":true,\"console\":false,\"tostatus\":false,\"complete\":\"payload\",\"targetType\":\"msg\",\"statusVal\":\"\",\"statusType\":\"auto\",\"x\":650,\"y\":440,\"wires\":[]},{\"id\":\"45db449f2dcf4ce1\",\"type\":\"comment\",\"z\":\"ae40d2da42dfdbb2\",\"name\":\"Flow 3 : Trigger measurement via I2C\",\"info\":\"\",\"x\":250,\"y\":540,\"wires\":[]},{\"id\":\"4635f68954c0b4f8\",\"type\":\"inject\",\"z\":\"ae40d2da42dfdbb2\",\"name\":\"Click to run\",\"props\":[{\"p\":\"payload\"},{\"p\":\"topic\",\"vt\":\"str\"}],\"repeat\":\"\",\"crontab\":\"\",\"once\":false,\"onceDelay\":0.1,\"topic\":\"\",\"payloadType\":\"date\",\"x\":180,\"y\":600,\"wires\":[[\"c6c3eb7076945329\"]]},{\"id\":\"c6c3eb7076945329\",\"type\":\"function\",\"z\":\"ae40d2da42dfdbb2\",\"name\":\"Trigger measurement\",\"func\":\"const HDC2080_I2C = 0x40;\\n\\nconst hdc = i2c.openSync(1);\\nhdc.writeByteSync(HDC2080_I2C, 0x0F, 0x01);\\nhdc.closeSync();\\n\\nmsg.payload = \\\"Measurement triggered\\\";\\n\\nreturn msg;\",\"outputs\":1,\"noerr\":0,\"initialize\":\"\",\"finalize\":\"\",\"libs\":[{\"var\":\"i2c\",\"module\":\"i2c-bus\"}],\"x\":410,\"y\":600,\"wires\":[[\"133fd4465ffca89a\"]]},{\"id\":\"133fd4465ffca89a\",\"type\":\"debug\",\"z\":\"ae40d2da42dfdbb2\",\"name\":\"Debug flow3\",\"active\":true,\"tosidebar\":true,\"console\":false,\"tostatus\":false,\"complete\":\"payload\",\"targetType\":\"msg\",\"statusVal\":\"\",\"statusType\":\"auto\",\"x\":650,\"y\":600,\"wires\":[]},{\"id\":\"48d7c05adb4a40de\",\"type\":\"comment\",\"z\":\"ae40d2da42dfdbb2\",\"name\":\"Flow 4 : Read temperature\",\"info\":\"\",\"x\":210,\"y\":700,\"wires\":[]},{\"id\":\"219d5a07b5b3d622\",\"type\":\"inject\",\"z\":\"ae40d2da42dfdbb2\",\"name\":\"Click to run\",\"props\":[{\"p\":\"payload\"},{\"p\":\"topic\",\"vt\":\"str\"}],\"repeat\":\"\",\"crontab\":\"\",\"once\":false,\"onceDelay\":0.1,\"topic\":\"\",\"payloadType\":\"date\",\"x\":180,\"y\":760,\"wires\":[[\"ab3d99f63335f7f8\"]]},{\"id\":\"ab3d99f63335f7f8\",\"type\":\"function\",\"z\":\"ae40d2da42dfdbb2\",\"name\":\"Read temperature\",\"func\":\"const HDC2080_I2C = 0x40;\\n\\nlet hdc = i2c.openSync(1);\\nlet r = hdc.readWordSync(HDC2080_I2C, 0x00);\\nhdc.closeSync();\\n\\nmsg.payload = (r / 65536) * 165 - 40.5;\\n\\nreturn msg;\",\"outputs\":1,\"noerr\":0,\"initialize\":\"\",\"finalize\":\"\",\"libs\":[{\"var\":\"i2c\",\"module\":\"i2c-bus\"}],\"x\":370,\"y\":760,\"wires\":[[\"d3cf046c0705ecb6\"]]},{\"id\":\"d3cf046c0705ecb6\",\"type\":\"debug\",\"z\":\"ae40d2da42dfdbb2\",\"name\":\"Debug flow4\",\"active\":true,\"tosidebar\":true,\"console\":false,\"tostatus\":false,\"complete\":\"payload\",\"targetType\":\"msg\",\"statusVal\":\"\",\"statusType\":\"auto\",\"x\":570,\"y\":760,\"wires\":[]},{\"id\":\"3c8ea04b57908649\",\"type\":\"inject\",\"z\":\"ae40d2da42dfdbb2\",\"name\":\"Click to run\",\"props\":[{\"p\":\"payload\"},{\"p\":\"topic\",\"vt\":\"str\"}],\"repeat\":\"\",\"crontab\":\"\",\"once\":false,\"onceDelay\":0.1,\"topic\":\"\",\"payloadType\":\"date\",\"x\":180,\"y\":920,\"wires\":[[\"4875a12e866cb662\"]]},{\"id\":\"5e30deb66330b5d9\",\"type\":\"comment\",\"z\":\"ae40d2da42dfdbb2\",\"name\":\"Flow4 : Read Humidity\",\"info\":\"\",\"x\":200,\"y\":860,\"wires\":[]},{\"id\":\"4875a12e866cb662\",\"type\":\"function\",\"z\":\"ae40d2da42dfdbb2\",\"name\":\"Read humidity\",\"func\":\"const HDC2080_I2C = 0x40;\\n\\nlet hdc = i2c.openSync(1);\\nlet r = hdc.readWordSync(HDC2080_I2C, 0x02);\\nhdc.closeSync();\\n\\nmsg.payload = r / 65536 * 100;\\n\\nreturn msg;\",\"outputs\":1,\"noerr\":0,\"initialize\":\"\",\"finalize\":\"\",\"libs\":[{\"var\":\"i2c\",\"module\":\"i2c-bus\"}],\"x\":360,\"y\":920,\"wires\":[[\"1cec6607f73c9622\"]]},{\"id\":\"1cec6607f73c9622\",\"type\":\"debug\",\"z\":\"ae40d2da42dfdbb2\",\"name\":\"Debug flow4\",\"active\":true,\"tosidebar\":true,\"console\":false,\"tostatus\":false,\"complete\":\"payload\",\"targetType\":\"msg\",\"statusVal\":\"\",\"statusType\":\"auto\",\"x\":570,\"y\":920,\"wires\":[]},{\"id\":\"66512f3e1e0938dc\",\"type\":\"comment\",\"z\":\"ae40d2da42dfdbb2\",\"name\":\"Flow 5 : Read MAX temperature\",\"info\":\"\",\"x\":230,\"y\":1020,\"wires\":[]},{\"id\":\"139778360202aca7\",\"type\":\"inject\",\"z\":\"ae40d2da42dfdbb2\",\"name\":\"Click to run\",\"props\":[{\"p\":\"payload\"},{\"p\":\"topic\",\"vt\":\"str\"}],\"repeat\":\"\",\"crontab\":\"\",\"once\":false,\"onceDelay\":0.1,\"topic\":\"\",\"payloadType\":\"date\",\"x\":180,\"y\":1080,\"wires\":[[\"e4bf6d56a2d1a00f\"]]},{\"id\":\"e4bf6d56a2d1a00f\",\"type\":\"function\",\"z\":\"ae40d2da42dfdbb2\",\"name\":\"Read MAX temperature\",\"func\":\"const HDC2080_I2C = 0x40;\\n\\nconst hdc = i2c.openSync(1);\\nlet r1 = hdc.readByteSync(HDC2080_I2C, 0x05);\\nhdc.closeSync();\\n\\nmsg.payload = (r1 / 256) * 165 - 40.5;\\nreturn msg;\",\"outputs\":1,\"noerr\":0,\"initialize\":\"\",\"finalize\":\"\",\"libs\":[{\"var\":\"i2c\",\"module\":\"i2c-bus\"}],\"x\":390,\"y\":1080,\"wires\":[[\"5f66699f757577b8\"]]},{\"id\":\"5f66699f757577b8\",\"type\":\"debug\",\"z\":\"ae40d2da42dfdbb2\",\"name\":\"Debug flow5\",\"active\":true,\"tosidebar\":true,\"console\":false,\"tostatus\":false,\"complete\":\"payload\",\"targetType\":\"msg\",\"statusVal\":\"\",\"statusType\":\"auto\",\"x\":610,\"y\":1080,\"wires\":[]},{\"id\":\"7acf3202ed2f34ac\",\"type\":\"comment\",\"z\":\"ae40d2da42dfdbb2\",\"name\":\"Flow 5 : Read MAX humidity\",\"info\":\"\",\"x\":220,\"y\":1180,\"wires\":[]},{\"id\":\"cd2f739e240a486b\",\"type\":\"inject\",\"z\":\"ae40d2da42dfdbb2\",\"name\":\"Click to run\",\"props\":[{\"p\":\"payload\"},{\"p\":\"topic\",\"vt\":\"str\"}],\"repeat\":\"\",\"crontab\":\"\",\"once\":false,\"onceDelay\":0.1,\"topic\":\"\",\"payloadType\":\"date\",\"x\":180,\"y\":1240,\"wires\":[[\"9ab0e0e884823fc5\"]]},{\"id\":\"9ab0e0e884823fc5\",\"type\":\"function\",\"z\":\"ae40d2da42dfdbb2\",\"name\":\"Read MAX humidity\",\"func\":\"const HDC2080_I2C = 0x40;\\n\\nconst hdc = i2c.openSync(1);\\nlet r1 = hdc.readByteSync(HDC2080_I2C, 0x06);\\nhdc.closeSync();\\n\\nmsg.payload = (r1 / 256) * 100;\\n\\nreturn msg;\",\"outputs\":1,\"noerr\":0,\"initialize\":\"\",\"finalize\":\"\",\"libs\":[{\"var\":\"i2c\",\"module\":\"i2c-bus\"}],\"x\":380,\"y\":1240,\"wires\":[[\"0f5aca8fc8b1f7a2\"]]},{\"id\":\"0f5aca8fc8b1f7a2\",\"type\":\"debug\",\"z\":\"ae40d2da42dfdbb2\",\"name\":\"Debug flow5\",\"active\":true,\"tosidebar\":true,\"console\":false,\"tostatus\":false,\"complete\":\"payload\",\"targetType\":\"msg\",\"statusVal\":\"\",\"statusType\":\"auto\",\"x\":610,\"y\":1240,\"wires\":[]},{\"id\":\"53fbefa876532be8\",\"type\":\"comment\",\"z\":\"ae40d2da42dfdbb2\",\"name\":\"Flow 6 : Soft reset\",\"info\":\"\",\"x\":190,\"y\":1360,\"wires\":[]},{\"id\":\"aa6dd67bf670c943\",\"type\":\"inject\",\"z\":\"ae40d2da42dfdbb2\",\"name\":\"Click to run\",\"props\":[{\"p\":\"payload\"},{\"p\":\"topic\",\"vt\":\"str\"}],\"repeat\":\"\",\"crontab\":\"\",\"once\":false,\"onceDelay\":0.1,\"topic\":\"\",\"payloadType\":\"date\",\"x\":180,\"y\":1420,\"wires\":[[\"3a16126dc33f9eb1\"]]},{\"id\":\"3a16126dc33f9eb1\",\"type\":\"function\",\"z\":\"ae40d2da42dfdbb2\",\"name\":\"Soft reset\",\"func\":\"const HDC2080_I2C = 0x40;\\n\\nconst hdc = i2c.openSync(1);\\nlet r1 = hdc.readByteSync(HDC2080_I2C, 0x0E);\\nhdc.writeByteSync(HDC2080_I2C, 0x0E, 0x80);\\nhdc.closeSync();\\n\\nconst hdc1 = i2c.openSync(1);\\nhdc1.writeByteSync(HDC2080_I2C, 0x0E, r1);\\nhdc1.closeSync();\\n\\nmsg.payload = \\\"0x\\\" + r1.toString(16).padStart(2, '0');\\nreturn msg;\",\"outputs\":1,\"noerr\":0,\"initialize\":\"\",\"finalize\":\"\",\"libs\":[{\"var\":\"i2c\",\"module\":\"i2c-bus\"}],\"x\":340,\"y\":1420,\"wires\":[[\"9e5323c9ae142a3e\"]]},{\"id\":\"9e5323c9ae142a3e\",\"type\":\"debug\",\"z\":\"ae40d2da42dfdbb2\",\"name\":\"Debug flow6\",\"active\":true,\"tosidebar\":true,\"console\":false,\"tostatus\":false,\"complete\":\"payload\",\"targetType\":\"msg\",\"statusVal\":\"\",\"statusType\":\"auto\",\"x\":510,\"y\":1420,\"wires\":[]},{\"id\":\"96b572ada0aa82ba\",\"type\":\"comment\",\"z\":\"ae40d2da42dfdbb2\",\"name\":\"Flow 7 : Read the interrupt enable register\",\"info\":\"\",\"x\":260,\"y\":1500,\"wires\":[]},{\"id\":\"b1b6eaaeb69dd864\",\"type\":\"inject\",\"z\":\"ae40d2da42dfdbb2\",\"name\":\"Click to run\",\"props\":[{\"p\":\"payload\"},{\"p\":\"topic\",\"vt\":\"str\"}],\"repeat\":\"\",\"crontab\":\"\",\"once\":false,\"onceDelay\":0.1,\"topic\":\"\",\"payloadType\":\"date\",\"x\":180,\"y\":1560,\"wires\":[[\"afc545b7f11c3b0d\"]]},{\"id\":\"afc545b7f11c3b0d\",\"type\":\"function\",\"z\":\"ae40d2da42dfdbb2\",\"name\":\"Read interrupt enable register\",\"func\":\"const HDC2080_I2C = 0x40;\\n\\nconst hdc = i2c.openSync(1);\\nlet r1 = hdc.readByteSync(HDC2080_I2C, 0x07);\\nhdc.closeSync();\\n\\nmsg.payload = \\\"0x\\\" + r1.toString(16).padStart(2, '0');\\nreturn msg;\",\"outputs\":1,\"noerr\":0,\"initialize\":\"\",\"finalize\":\"\",\"libs\":[{\"var\":\"i2c\",\"module\":\"i2c-bus\"}],\"x\":410,\"y\":1560,\"wires\":[[\"6ed64a45ebcf5635\"]]},{\"id\":\"6ed64a45ebcf5635\",\"type\":\"debug\",\"z\":\"ae40d2da42dfdbb2\",\"name\":\"Debug flow7\",\"active\":true,\"tosidebar\":true,\"console\":false,\"tostatus\":false,\"complete\":\"payload\",\"targetType\":\"msg\",\"statusVal\":\"\",\"statusType\":\"auto\",\"x\":640,\"y\":1560,\"wires\":[]},{\"id\":\"5b6c3e16bba31549\",\"type\":\"inject\",\"z\":\"ae40d2da42dfdbb2\",\"name\":\"Click to run\",\"props\":[{\"p\":\"payload\"},{\"p\":\"topic\",\"vt\":\"str\"}],\"repeat\":\"\",\"crontab\":\"\",\"once\":false,\"onceDelay\":0.1,\"topic\":\"\",\"payloadType\":\"date\",\"x\":180,\"y\":1740,\"wires\":[[\"cc0c715c69b9385f\"]]},{\"id\":\"773cc86a0a24624a\",\"type\":\"comment\",\"z\":\"ae40d2da42dfdbb2\",\"name\":\"Flow 7 : Write value 0x80 to interrupt enable register\",\"info\":\"\",\"x\":290,\"y\":1680,\"wires\":[]},{\"id\":\"cc0c715c69b9385f\",\"type\":\"function\",\"z\":\"ae40d2da42dfdbb2\",\"name\":\"Write interrupt enable register\",\"func\":\"const HDC2080_I2C = 0x40;\\n\\nconst hdc = i2c.openSync(1);\\nhdc.writeByteSync(HDC2080_I2C, 0x07, 0x80);\\nhdc.closeSync();\\n\\nmsg.payload = \\\"0x80\\\";\\nreturn msg;\",\"outputs\":1,\"noerr\":0,\"initialize\":\"\",\"finalize\":\"\",\"libs\":[{\"var\":\"i2c\",\"module\":\"i2c-bus\"}],\"x\":410,\"y\":1740,\"wires\":[[\"9b9077d8f2270c52\"]]},{\"id\":\"9b9077d8f2270c52\",\"type\":\"debug\",\"z\":\"ae40d2da42dfdbb2\",\"name\":\"Debug flow7\",\"active\":true,\"tosidebar\":true,\"console\":false,\"tostatus\":false,\"complete\":\"payload\",\"targetType\":\"msg\",\"statusVal\":\"\",\"statusType\":\"auto\",\"x\":650,\"y\":1740,\"wires\":[]},{\"id\":\"1ad9ad6943e71d10\",\"type\":\"rpi-gpio in\",\"z\":\"ae40d2da42dfdbb2\",\"name\":\"\",\"pin\":\"11\",\"intype\":\"tri\",\"debounce\":\"0\",\"read\":false,\"x\":150,\"y\":1920,\"wires\":[[\"54ed70b77d532554\"]]},{\"id\":\"54ed70b77d532554\",\"type\":\"debug\",\"z\":\"ae40d2da42dfdbb2\",\"name\":\"PIN - GPIO17 - PIN 11 \",\"active\":true,\"tosidebar\":true,\"console\":false,\"tostatus\":false,\"complete\":\"payload\",\"targetType\":\"msg\",\"statusVal\":\"\",\"statusType\":\"auto\",\"x\":360,\"y\":1920,\"wires\":[]},{\"id\":\"8905e7dc3b52d696\",\"type\":\"comment\",\"z\":\"ae40d2da42dfdbb2\",\"name\":\"GPIO17 = PIN 11\",\"info\":\"\",\"x\":180,\"y\":1880,\"wires\":[]},{\"id\":\"fced05ac8073f868\",\"type\":\"comment\",\"z\":\"ae40d2da42dfdbb2\",\"name\":\"Flow 8 : 1 reading every 10 seconds\",\"info\":\"\",\"x\":240,\"y\":2040,\"wires\":[]},{\"id\":\"5c8a65ea991b187c\",\"type\":\"inject\",\"z\":\"ae40d2da42dfdbb2\",\"name\":\"Click to run\",\"props\":[{\"p\":\"payload\"},{\"p\":\"topic\",\"vt\":\"str\"}],\"repeat\":\"\",\"crontab\":\"\",\"once\":false,\"onceDelay\":0.1,\"topic\":\"\",\"payloadType\":\"date\",\"x\":180,\"y\":2100,\"wires\":[[\"b01133b39caa746c\"]]},{\"id\":\"b01133b39caa746c\",\"type\":\"function\",\"z\":\"ae40d2da42dfdbb2\",\"name\":\"1 reading every 10 seconds\",\"func\":\"const HDC2080_I2C = 0x40;\\n\\nconst hdc = i2c.openSync(1);\\nhdc.writeByteSync(HDC2080_I2C, 0x0E, 0x36);\\nhdc.closeSync();\\n\\nmsg.payload = \\\"0x36\\\";\\nreturn msg;\",\"outputs\":1,\"noerr\":0,\"initialize\":\"\",\"finalize\":\"\",\"libs\":[{\"var\":\"i2c\",\"module\":\"i2c-bus\"}],\"x\":400,\"y\":2100,\"wires\":[[\"020cd089a072125c\"]]},{\"id\":\"020cd089a072125c\",\"type\":\"debug\",\"z\":\"ae40d2da42dfdbb2\",\"name\":\"Debuf flow8\",\"active\":true,\"tosidebar\":true,\"console\":false,\"tostatus\":false,\"complete\":\"payload\",\"targetType\":\"msg\",\"statusVal\":\"\",\"statusType\":\"auto\",\"x\":630,\"y\":2100,\"wires\":[]},{\"id\":\"ce2acd20c5ad696e\",\"type\":\"comment\",\"z\":\"ae40d2da42dfdbb2\",\"name\":\"Flow 9 : Playing with the heater - 1 sample every 5 seconds\",\"info\":\"\",\"x\":320,\"y\":2220,\"wires\":[]},{\"id\":\"e3b67be803fb22e1\",\"type\":\"inject\",\"z\":\"ae40d2da42dfdbb2\",\"name\":\"Click to heat\",\"props\":[{\"p\":\"payload\"},{\"p\":\"topic\",\"vt\":\"str\"}],\"repeat\":\"\",\"crontab\":\"\",\"once\":false,\"onceDelay\":0.1,\"topic\":\"\",\"payloadType\":\"date\",\"x\":210,\"y\":2300,\"wires\":[[\"fc763414380a8a97\"]]},{\"id\":\"fc763414380a8a97\",\"type\":\"function\",\"z\":\"ae40d2da42dfdbb2\",\"name\":\"Heater ON - 0x4E\",\"func\":\"const HDC2080_I2C = 0x40;\\n\\nconst hdc = i2c.openSync(1);\\nhdc.writeByteSync(HDC2080_I2C, 0x0E, 0x4E);\\nhdc.closeSync();\\n\\nmsg.payload = \\\"The heater is ON - Check temperature register\\\";\\nreturn msg;\",\"outputs\":1,\"noerr\":0,\"initialize\":\"\",\"finalize\":\"\",\"libs\":[{\"var\":\"i2c\",\"module\":\"i2c-bus\"}],\"x\":400,\"y\":2300,\"wires\":[[\"069f453717167d28\",\"36d0ce4a604bab1c\"]]},{\"id\":\"538a3ccd51affbb3\",\"type\":\"function\",\"z\":\"ae40d2da42dfdbb2\",\"name\":\"Heater OFF - 0x46\",\"func\":\"const HDC2080_I2C = 0x40;\\n\\nconst hdc = i2c.openSync(1);\\nhdc.writeByteSync(HDC2080_I2C, 0x0E, 0x46);\\nhdc.closeSync();\\n\\nmsg.payload = \\\"The heater is OFF\\\";\\nreturn msg;\",\"outputs\":1,\"noerr\":0,\"initialize\":\"\",\"finalize\":\"\",\"libs\":[{\"var\":\"i2c\",\"module\":\"i2c-bus\"}],\"x\":570,\"y\":2420,\"wires\":[[\"8b003c2060dbda78\"]]},{\"id\":\"6e7c00ad4c07de04\",\"type\":\"inject\",\"z\":\"ae40d2da42dfdbb2\",\"name\":\"Click to cool off\",\"props\":[{\"p\":\"payload\"},{\"p\":\"topic\",\"vt\":\"str\"}],\"repeat\":\"\",\"crontab\":\"\",\"once\":false,\"onceDelay\":0.1,\"topic\":\"\",\"payloadType\":\"date\",\"x\":220,\"y\":2420,\"wires\":[[\"538a3ccd51affbb3\"]]},{\"id\":\"069f453717167d28\",\"type\":\"debug\",\"z\":\"ae40d2da42dfdbb2\",\"name\":\"Debug Flow9\",\"active\":true,\"tosidebar\":true,\"console\":false,\"tostatus\":false,\"complete\":\"payload\",\"targetType\":\"msg\",\"statusVal\":\"\",\"statusType\":\"auto\",\"x\":670,\"y\":2300,\"wires\":[]},{\"id\":\"8b003c2060dbda78\",\"type\":\"debug\",\"z\":\"ae40d2da42dfdbb2\",\"name\":\"Debug Flow9\",\"active\":true,\"tosidebar\":true,\"console\":false,\"tostatus\":false,\"complete\":\"payload\",\"targetType\":\"msg\",\"statusVal\":\"\",\"statusType\":\"auto\",\"x\":770,\"y\":2420,\"wires\":[]},{\"id\":\"36d0ce4a604bab1c\",\"type\":\"delay\",\"z\":\"ae40d2da42dfdbb2\",\"name\":\"\",\"pauseType\":\"delay\",\"timeout\":\"12\",\"timeoutUnits\":\"seconds\",\"rate\":\"1\",\"nbRateUnits\":\"1\",\"rateUnits\":\"second\",\"randomFirst\":\"1\",\"randomLast\":\"5\",\"randomUnits\":\"seconds\",\"drop\":false,\"allowrate\":false,\"x\":490,\"y\":2360,\"wires\":[[\"538a3ccd51affbb3\"]]}]","title":"Putting it all together"},{"location":"amm/","text":"Auto measurement mode How it works The HDC2080 sensor has two modes of operation to generate measurements. The auto measurement mode triggers measurements in programmable intervals that can range from a slow 1 sample every 2 minutes to a fast pace of 5 samples per second. The second mode of operation is triggering them with I2C commands, a kind of reading on demand. What is the best mode of operation ? It really depends on what you need. If you build a stand alone temperature and humidity device, lets say using the HDC2080 connected to a microcontroller and using an OLED display then sure enough you want to activate the auto measurement. Now, if you hook up the HDC2080 to a single board computer, like the Raspberry PI, and uses Node-RED to control an automation system, then most likely you won\u00b4t need auto measurement. You can grab temperature and humidity data as you need. In our examples in this tutorial we will disable the auto measurement mode to trigger readings via I2C. Auto measurement can be tricky There is something you will need to overcome when using the auto measurement mode. It may happen that you issue an I2C command to read the temperature and humidity registers at the exact time the HDC2080 is updating its internal registers. That can lead to wrong readings. It is not difficult to reproduce this issue. Just program the device to generate 5 samples per second and start reading the temperature and humidity registers at random. Not even the interrupt pin can help you to circumvent this issue. Apparently the HDC2080 does not have a mechanism to avoid this from happening, at least that I am aware of.","title":"Auto measurement mode"},{"location":"amm/#auto-measurement-mode","text":"","title":"Auto measurement mode"},{"location":"amm/#how-it-works","text":"The HDC2080 sensor has two modes of operation to generate measurements. The auto measurement mode triggers measurements in programmable intervals that can range from a slow 1 sample every 2 minutes to a fast pace of 5 samples per second. The second mode of operation is triggering them with I2C commands, a kind of reading on demand.","title":"How it works"},{"location":"amm/#what-is-the-best-mode-of-operation","text":"It really depends on what you need. If you build a stand alone temperature and humidity device, lets say using the HDC2080 connected to a microcontroller and using an OLED display then sure enough you want to activate the auto measurement. Now, if you hook up the HDC2080 to a single board computer, like the Raspberry PI, and uses Node-RED to control an automation system, then most likely you won\u00b4t need auto measurement. You can grab temperature and humidity data as you need. In our examples in this tutorial we will disable the auto measurement mode to trigger readings via I2C.","title":"What is the best mode of operation ?"},{"location":"amm/#auto-measurement-can-be-tricky","text":"There is something you will need to overcome when using the auto measurement mode. It may happen that you issue an I2C command to read the temperature and humidity registers at the exact time the HDC2080 is updating its internal registers. That can lead to wrong readings. It is not difficult to reproduce this issue. Just program the device to generate 5 samples per second and start reading the temperature and humidity registers at random. Not even the interrupt pin can help you to circumvent this issue. Apparently the HDC2080 does not have a mechanism to avoid this from happening, at least that I am aware of.","title":"Auto measurement can be tricky"},{"location":"calibration/","text":"Calibration The HDC2080 sensor is calibrated during manufacturing. I did not have the opportunity to check how accurate is the measurement as I lack a precise reference. In case your device is not well calibrated you have the possibility intervene. There is a mechanism to allow you to add a fixed offset (positive or negative) to the readings. This is done with the use of two purpose specific registers available in the HDC2080.","title":"Calibration"},{"location":"calibration/#calibration","text":"The HDC2080 sensor is calibrated during manufacturing. I did not have the opportunity to check how accurate is the measurement as I lack a precise reference. In case your device is not well calibrated you have the possibility intervene. There is a mechanism to allow you to add a fixed offset (positive or negative) to the readings. This is done with the use of two purpose specific registers available in the HDC2080.","title":"Calibration"},{"location":"chart/","text":"Chart","title":"Chart"},{"location":"chart/#chart","text":"","title":"Chart"},{"location":"configurationregister/","text":"Configuration register (0x0E) You already know that the HDC2080 has two modes of operation in regards to reading values. You change the operating mode with 3 bits from this register to program the sample rate for the measurements or to disable this auto measurement mode allowing readings only via I2C. Heater The heater is a built-in mechanism in the silicon added to prevent condensation that will interfere with measurements. As explained in the device datasheet the sensor will suffer an offset in humidity readins in case it is exposed to high humidity for a long time. Wise use of the heater can avoid this situation. Heating, if necessary, should be strickly controlled by your application software and should not remain activated for a long time. And long time in this case is few seconds. The heating process will rise the temperature of the whole integrated circuit and you have to avoid reaching the maximum dictate by the specifications, which is 85\u00ba celsius. Also take into consideration that heating draws a lot of current and therefore power, compared with the normal consumption without heating. We wil build a Node-RED flow that will heat the device for a few seconds and read the temperature sensor to see this feature working. Interrupt mode As you can see in the datasheet table for this register there are two modes for using the interrupt pin: level sensitivity and comparator. Basically these modes determine how long the interrupt pin will remain active. You can use the level sensivity mode whereby the pin output will change dinamically following the value it is tracking. Alternatively you can use it the the comparator mode where it will work like as flag. In this mode it will remain active until you read the register. This is more or less like a mailbox flag used in United States, where the postman will raise the flag to signal you that mail arrived. Once you grab the mail you move the lever down so no one else in your home will bother going to take the mail.","title":"Configuration register"},{"location":"configurationregister/#configuration-register-0x0e","text":"You already know that the HDC2080 has two modes of operation in regards to reading values. You change the operating mode with 3 bits from this register to program the sample rate for the measurements or to disable this auto measurement mode allowing readings only via I2C.","title":"Configuration register (0x0E)"},{"location":"configurationregister/#heater","text":"The heater is a built-in mechanism in the silicon added to prevent condensation that will interfere with measurements. As explained in the device datasheet the sensor will suffer an offset in humidity readins in case it is exposed to high humidity for a long time. Wise use of the heater can avoid this situation. Heating, if necessary, should be strickly controlled by your application software and should not remain activated for a long time. And long time in this case is few seconds. The heating process will rise the temperature of the whole integrated circuit and you have to avoid reaching the maximum dictate by the specifications, which is 85\u00ba celsius. Also take into consideration that heating draws a lot of current and therefore power, compared with the normal consumption without heating. We wil build a Node-RED flow that will heat the device for a few seconds and read the temperature sensor to see this feature working.","title":"Heater"},{"location":"configurationregister/#interrupt-mode","text":"As you can see in the datasheet table for this register there are two modes for using the interrupt pin: level sensitivity and comparator. Basically these modes determine how long the interrupt pin will remain active. You can use the level sensivity mode whereby the pin output will change dinamically following the value it is tracking. Alternatively you can use it the the comparator mode where it will work like as flag. In this mode it will remain active until you read the register. This is more or less like a mailbox flag used in United States, where the postman will raise the flag to signal you that mail arrived. Once you grab the mail you move the lever down so no one else in your home will bother going to take the mail.","title":"Interrupt mode"},{"location":"flowmanufacturer/","text":"Read manufacturer ID In this first flow we will do something very simple: read the registers that hold the manufacturer ID. These are the registers 0xFC and 0xFD. For that purpose we will use a function node. The code is straightforward. We open the bus and read a 16-bit word with and then close the bus. The reading is formatted to be displayed as a hexadecimal value. Here below the code inside the function node: const HDC2080_I2C = 0x40; const hdc = i2c.openSync(1); let r = hdc.readWordSync(HDC2080_I2C, 0xFC); hdc.closeSync(); msg.payload = `Manufacturer ID: 0x${r.toString(16)}`; return msg; Note Don\u00b4t forget to configure the setup tab of the function node as shown in the previous section, otherwise your flow won\u00b4t work. Below the flow for you to copy and import to Node-RED. [{\"id\":\"ae40d2da42dfdbb2\",\"type\":\"tab\",\"label\":\"Flow 1\",\"disabled\":false,\"info\":\"\"},{\"id\":\"e207ea6471f306f4\",\"type\":\"inject\",\"z\":\"ae40d2da42dfdbb2\",\"name\":\"Click to run\",\"props\":[{\"p\":\"payload\"},{\"p\":\"topic\",\"vt\":\"str\"}],\"repeat\":\"\",\"crontab\":\"\",\"once\":false,\"onceDelay\":0.1,\"topic\":\"\",\"payloadType\":\"date\",\"x\":180,\"y\":140,\"wires\":[[\"2ca8939ae6b0ac08\"]]},{\"id\":\"8f852f4ea6291a5e\",\"type\":\"debug\",\"z\":\"ae40d2da42dfdbb2\",\"name\":\"Debug flow1\",\"active\":true,\"tosidebar\":true,\"console\":false,\"tostatus\":true,\"complete\":\"payload\",\"targetType\":\"msg\",\"statusVal\":\"payload\",\"statusType\":\"auto\",\"x\":630,\"y\":140,\"wires\":[]},{\"id\":\"3676564ac6445fe1\",\"type\":\"comment\",\"z\":\"ae40d2da42dfdbb2\",\"name\":\"Flow 1 : Read manufacturer ID\",\"info\":\"\",\"x\":210,\"y\":80,\"wires\":[]},{\"id\":\"2ca8939ae6b0ac08\",\"type\":\"function\",\"z\":\"ae40d2da42dfdbb2\",\"name\":\"Read manufacturer ID\",\"func\":\"const HDC2080_I2C = 0x40;\\n\\nconst hdc = i2c.openSync(1);\\nlet r = hdc.readWordSync(HDC2080_I2C, 0xFC);\\nhdc.closeSync();\\n\\nmsg.payload = `Manufacturer ID: 0x${r.toString(16)}`;\\nreturn msg;\",\"outputs\":1,\"noerr\":0,\"initialize\":\"\",\"finalize\":\"\",\"libs\":[{\"var\":\"i2c\",\"module\":\"i2c-bus\"}],\"x\":400,\"y\":140,\"wires\":[[\"8f852f4ea6291a5e\"]]}] This is what you will see in Node-RED editor after importing the above flow. Below the result in the debug panel: Note But.. wait. The datasheet says we should read 0x4954. Maybe our code is wrong ? I don\u00b4t think so. Most likely there is a typo in the datasheet. Or perhaps I am using a counterfeit device that had the manufacturer ID changed on purpose to avoid legal sanctions ? No, very unlikely. This flow was a good start point as we could read a register without programming before the device. In the next session we will learn how to write to registers and configure the device.","title":"Read manufacturer ID"},{"location":"flowmanufacturer/#read-manufacturer-id","text":"In this first flow we will do something very simple: read the registers that hold the manufacturer ID. These are the registers 0xFC and 0xFD. For that purpose we will use a function node. The code is straightforward. We open the bus and read a 16-bit word with and then close the bus. The reading is formatted to be displayed as a hexadecimal value. Here below the code inside the function node: const HDC2080_I2C = 0x40; const hdc = i2c.openSync(1); let r = hdc.readWordSync(HDC2080_I2C, 0xFC); hdc.closeSync(); msg.payload = `Manufacturer ID: 0x${r.toString(16)}`; return msg; Note Don\u00b4t forget to configure the setup tab of the function node as shown in the previous section, otherwise your flow won\u00b4t work. Below the flow for you to copy and import to Node-RED. [{\"id\":\"ae40d2da42dfdbb2\",\"type\":\"tab\",\"label\":\"Flow 1\",\"disabled\":false,\"info\":\"\"},{\"id\":\"e207ea6471f306f4\",\"type\":\"inject\",\"z\":\"ae40d2da42dfdbb2\",\"name\":\"Click to run\",\"props\":[{\"p\":\"payload\"},{\"p\":\"topic\",\"vt\":\"str\"}],\"repeat\":\"\",\"crontab\":\"\",\"once\":false,\"onceDelay\":0.1,\"topic\":\"\",\"payloadType\":\"date\",\"x\":180,\"y\":140,\"wires\":[[\"2ca8939ae6b0ac08\"]]},{\"id\":\"8f852f4ea6291a5e\",\"type\":\"debug\",\"z\":\"ae40d2da42dfdbb2\",\"name\":\"Debug flow1\",\"active\":true,\"tosidebar\":true,\"console\":false,\"tostatus\":true,\"complete\":\"payload\",\"targetType\":\"msg\",\"statusVal\":\"payload\",\"statusType\":\"auto\",\"x\":630,\"y\":140,\"wires\":[]},{\"id\":\"3676564ac6445fe1\",\"type\":\"comment\",\"z\":\"ae40d2da42dfdbb2\",\"name\":\"Flow 1 : Read manufacturer ID\",\"info\":\"\",\"x\":210,\"y\":80,\"wires\":[]},{\"id\":\"2ca8939ae6b0ac08\",\"type\":\"function\",\"z\":\"ae40d2da42dfdbb2\",\"name\":\"Read manufacturer ID\",\"func\":\"const HDC2080_I2C = 0x40;\\n\\nconst hdc = i2c.openSync(1);\\nlet r = hdc.readWordSync(HDC2080_I2C, 0xFC);\\nhdc.closeSync();\\n\\nmsg.payload = `Manufacturer ID: 0x${r.toString(16)}`;\\nreturn msg;\",\"outputs\":1,\"noerr\":0,\"initialize\":\"\",\"finalize\":\"\",\"libs\":[{\"var\":\"i2c\",\"module\":\"i2c-bus\"}],\"x\":400,\"y\":140,\"wires\":[[\"8f852f4ea6291a5e\"]]}] This is what you will see in Node-RED editor after importing the above flow. Below the result in the debug panel: Note But.. wait. The datasheet says we should read 0x4954. Maybe our code is wrong ? I don\u00b4t think so. Most likely there is a typo in the datasheet. Or perhaps I am using a counterfeit device that had the manufacturer ID changed on purpose to avoid legal sanctions ? No, very unlikely. This flow was a good start point as we could read a register without programming before the device. In the next session we will learn how to write to registers and configure the device.","title":"Read manufacturer ID"},{"location":"gauge/","text":"Gauge We are used to visualise temperature and humidity using gauges. Ou dashboard uses awesome gauges developeded by Hotnip using pure HTML and CSS. This is how the flow looks like: and this is the view in the dashboard:","title":"Gauge"},{"location":"gauge/#gauge","text":"We are used to visualise temperature and humidity using gauges. Ou dashboard uses awesome gauges developeded by Hotnip using pure HTML and CSS. This is how the flow looks like: and this is the view in the dashboard:","title":"Gauge"},{"location":"gpiointerrupt/","text":"Configuring a GPIO pin for interrupt We are going to add a Raspberry PI specific node to our flow. Search the node palete in the left side of the editor for the node rpi-gpio in and drag it to the canvas along with a debug node. Double click the node to enter the configuration setup and use below configuration. Now deploy your flow to ensure the configuration is saved and go find a jumper cable to connect the INT pin in the HDC2080 to the pin 11 in your Raspberry PI. When the wiring is complete run your flow by clicking in the inject node to trigger a measurement (Flow 3 : Trigger measurement via I2C). If all is good you will see some data being displayed in the debug node. When you trigerred the measurement the interrupt pin changed from low level (level 0) to high level (level 1) and this is what the debug panel shows you. The GPIO pin is telling you that there ar enew measurements available in the temperature and humidity registers. Let\u00b4s then grab the latest measument by clicking in the inject node that reads temperatue (Flow 4 : Read temperature). Watch the debug panel. You got the latest temperature displayed in th debug panel and can see that the interrupt pin changed again to low level. This is exactly what we were expecting.","title":"GPIO pin for interrupt"},{"location":"gpiointerrupt/#configuring-a-gpio-pin-for-interrupt","text":"We are going to add a Raspberry PI specific node to our flow. Search the node palete in the left side of the editor for the node rpi-gpio in and drag it to the canvas along with a debug node. Double click the node to enter the configuration setup and use below configuration. Now deploy your flow to ensure the configuration is saved and go find a jumper cable to connect the INT pin in the HDC2080 to the pin 11 in your Raspberry PI. When the wiring is complete run your flow by clicking in the inject node to trigger a measurement (Flow 3 : Trigger measurement via I2C). If all is good you will see some data being displayed in the debug node. When you trigerred the measurement the interrupt pin changed from low level (level 0) to high level (level 1) and this is what the debug panel shows you. The GPIO pin is telling you that there ar enew measurements available in the temperature and humidity registers. Let\u00b4s then grab the latest measument by clicking in the inject node that reads temperatue (Flow 4 : Read temperature). Watch the debug panel. You got the latest temperature displayed in th debug panel and can see that the interrupt pin changed again to low level. This is exactly what we were expecting.","title":"Configuring a GPIO pin for interrupt"},{"location":"heating/","text":"Playing with the heater Danger It is dangerous to play with the heater. Overheating may damage the device. You have been warned. Use at your own risk. The following flow will turn on the heater for a few seconds and then will (hopefully) power it off. During this time you can check the temperature register (Flow 4) to see the increase. Auto measurement is enabled to generated a new value every 5 seconds. Below the flow for you to copy and import to Node-RED. [{\"id\":\"ce2acd20c5ad696e\",\"type\":\"comment\",\"z\":\"ae40d2da42dfdbb2\",\"name\":\"Flow 9 : Playing with the heater - 1 sample every 5 seconds\",\"info\":\"\",\"x\":320,\"y\":2220,\"wires\":[]},{\"id\":\"e3b67be803fb22e1\",\"type\":\"inject\",\"z\":\"ae40d2da42dfdbb2\",\"name\":\"Click to heat\",\"props\":[{\"p\":\"payload\"},{\"p\":\"topic\",\"vt\":\"str\"}],\"repeat\":\"\",\"crontab\":\"\",\"once\":false,\"onceDelay\":0.1,\"topic\":\"\",\"payloadType\":\"date\",\"x\":210,\"y\":2300,\"wires\":[[\"fc763414380a8a97\"]]},{\"id\":\"fc763414380a8a97\",\"type\":\"function\",\"z\":\"ae40d2da42dfdbb2\",\"name\":\"Heater ON - 0x4E\",\"func\":\"const HDC2080_I2C = 0x40;\\n\\nconst hdc = i2c.openSync(1);\\nhdc.writeByteSync(HDC2080_I2C, 0x0E, 0x4E);\\nhdc.closeSync();\\n\\nmsg.payload = \\\"The heater is ON - Check temperature register\\\";\\nreturn msg;\",\"outputs\":1,\"noerr\":0,\"initialize\":\"\",\"finalize\":\"\",\"libs\":[{\"var\":\"i2c\",\"module\":\"i2c-bus\"}],\"x\":400,\"y\":2300,\"wires\":[[\"069f453717167d28\",\"36d0ce4a604bab1c\"]]},{\"id\":\"538a3ccd51affbb3\",\"type\":\"function\",\"z\":\"ae40d2da42dfdbb2\",\"name\":\"Heater OFF - 0x46\",\"func\":\"const HDC2080_I2C = 0x40;\\n\\nconst hdc = i2c.openSync(1);\\nhdc.writeByteSync(HDC2080_I2C, 0x0E, 0x46);\\nhdc.closeSync();\\n\\nmsg.payload = \\\"The heater is OFF\\\";\\nreturn msg;\",\"outputs\":1,\"noerr\":0,\"initialize\":\"\",\"finalize\":\"\",\"libs\":[{\"var\":\"i2c\",\"module\":\"i2c-bus\"}],\"x\":570,\"y\":2420,\"wires\":[[\"8b003c2060dbda78\"]]},{\"id\":\"6e7c00ad4c07de04\",\"type\":\"inject\",\"z\":\"ae40d2da42dfdbb2\",\"name\":\"Click to cool off\",\"props\":[{\"p\":\"payload\"},{\"p\":\"topic\",\"vt\":\"str\"}],\"repeat\":\"\",\"crontab\":\"\",\"once\":false,\"onceDelay\":0.1,\"topic\":\"\",\"payloadType\":\"date\",\"x\":220,\"y\":2420,\"wires\":[[\"538a3ccd51affbb3\"]]},{\"id\":\"069f453717167d28\",\"type\":\"debug\",\"z\":\"ae40d2da42dfdbb2\",\"name\":\"Debug Flow9\",\"active\":true,\"tosidebar\":true,\"console\":false,\"tostatus\":false,\"complete\":\"payload\",\"targetType\":\"msg\",\"statusVal\":\"\",\"statusType\":\"auto\",\"x\":670,\"y\":2300,\"wires\":[]},{\"id\":\"8b003c2060dbda78\",\"type\":\"debug\",\"z\":\"ae40d2da42dfdbb2\",\"name\":\"Debug Flow9\",\"active\":true,\"tosidebar\":true,\"console\":false,\"tostatus\":false,\"complete\":\"payload\",\"targetType\":\"msg\",\"statusVal\":\"\",\"statusType\":\"auto\",\"x\":770,\"y\":2420,\"wires\":[]},{\"id\":\"36d0ce4a604bab1c\",\"type\":\"delay\",\"z\":\"ae40d2da42dfdbb2\",\"name\":\"\",\"pauseType\":\"delay\",\"timeout\":\"12\",\"timeoutUnits\":\"seconds\",\"rate\":\"1\",\"nbRateUnits\":\"1\",\"rateUnits\":\"second\",\"randomFirst\":\"1\",\"randomLast\":\"5\",\"randomUnits\":\"seconds\",\"drop\":false,\"allowrate\":false,\"x\":490,\"y\":2360,\"wires\":[[\"538a3ccd51affbb3\"]]}] You may want to check also the value of MAX temperature register (flow 5) Note Don\u00b4t forget to trigger a manual measurement (flow 3) first time after programming auto measurement. In my testing the MAX temperature reached nearly 57\u00ba celsius.","title":"Playing with the heater"},{"location":"heating/#playing-with-the-heater","text":"Danger It is dangerous to play with the heater. Overheating may damage the device. You have been warned. Use at your own risk. The following flow will turn on the heater for a few seconds and then will (hopefully) power it off. During this time you can check the temperature register (Flow 4) to see the increase. Auto measurement is enabled to generated a new value every 5 seconds. Below the flow for you to copy and import to Node-RED. [{\"id\":\"ce2acd20c5ad696e\",\"type\":\"comment\",\"z\":\"ae40d2da42dfdbb2\",\"name\":\"Flow 9 : Playing with the heater - 1 sample every 5 seconds\",\"info\":\"\",\"x\":320,\"y\":2220,\"wires\":[]},{\"id\":\"e3b67be803fb22e1\",\"type\":\"inject\",\"z\":\"ae40d2da42dfdbb2\",\"name\":\"Click to heat\",\"props\":[{\"p\":\"payload\"},{\"p\":\"topic\",\"vt\":\"str\"}],\"repeat\":\"\",\"crontab\":\"\",\"once\":false,\"onceDelay\":0.1,\"topic\":\"\",\"payloadType\":\"date\",\"x\":210,\"y\":2300,\"wires\":[[\"fc763414380a8a97\"]]},{\"id\":\"fc763414380a8a97\",\"type\":\"function\",\"z\":\"ae40d2da42dfdbb2\",\"name\":\"Heater ON - 0x4E\",\"func\":\"const HDC2080_I2C = 0x40;\\n\\nconst hdc = i2c.openSync(1);\\nhdc.writeByteSync(HDC2080_I2C, 0x0E, 0x4E);\\nhdc.closeSync();\\n\\nmsg.payload = \\\"The heater is ON - Check temperature register\\\";\\nreturn msg;\",\"outputs\":1,\"noerr\":0,\"initialize\":\"\",\"finalize\":\"\",\"libs\":[{\"var\":\"i2c\",\"module\":\"i2c-bus\"}],\"x\":400,\"y\":2300,\"wires\":[[\"069f453717167d28\",\"36d0ce4a604bab1c\"]]},{\"id\":\"538a3ccd51affbb3\",\"type\":\"function\",\"z\":\"ae40d2da42dfdbb2\",\"name\":\"Heater OFF - 0x46\",\"func\":\"const HDC2080_I2C = 0x40;\\n\\nconst hdc = i2c.openSync(1);\\nhdc.writeByteSync(HDC2080_I2C, 0x0E, 0x46);\\nhdc.closeSync();\\n\\nmsg.payload = \\\"The heater is OFF\\\";\\nreturn msg;\",\"outputs\":1,\"noerr\":0,\"initialize\":\"\",\"finalize\":\"\",\"libs\":[{\"var\":\"i2c\",\"module\":\"i2c-bus\"}],\"x\":570,\"y\":2420,\"wires\":[[\"8b003c2060dbda78\"]]},{\"id\":\"6e7c00ad4c07de04\",\"type\":\"inject\",\"z\":\"ae40d2da42dfdbb2\",\"name\":\"Click to cool off\",\"props\":[{\"p\":\"payload\"},{\"p\":\"topic\",\"vt\":\"str\"}],\"repeat\":\"\",\"crontab\":\"\",\"once\":false,\"onceDelay\":0.1,\"topic\":\"\",\"payloadType\":\"date\",\"x\":220,\"y\":2420,\"wires\":[[\"538a3ccd51affbb3\"]]},{\"id\":\"069f453717167d28\",\"type\":\"debug\",\"z\":\"ae40d2da42dfdbb2\",\"name\":\"Debug Flow9\",\"active\":true,\"tosidebar\":true,\"console\":false,\"tostatus\":false,\"complete\":\"payload\",\"targetType\":\"msg\",\"statusVal\":\"\",\"statusType\":\"auto\",\"x\":670,\"y\":2300,\"wires\":[]},{\"id\":\"8b003c2060dbda78\",\"type\":\"debug\",\"z\":\"ae40d2da42dfdbb2\",\"name\":\"Debug Flow9\",\"active\":true,\"tosidebar\":true,\"console\":false,\"tostatus\":false,\"complete\":\"payload\",\"targetType\":\"msg\",\"statusVal\":\"\",\"statusType\":\"auto\",\"x\":770,\"y\":2420,\"wires\":[]},{\"id\":\"36d0ce4a604bab1c\",\"type\":\"delay\",\"z\":\"ae40d2da42dfdbb2\",\"name\":\"\",\"pauseType\":\"delay\",\"timeout\":\"12\",\"timeoutUnits\":\"seconds\",\"rate\":\"1\",\"nbRateUnits\":\"1\",\"rateUnits\":\"second\",\"randomFirst\":\"1\",\"randomLast\":\"5\",\"randomUnits\":\"seconds\",\"drop\":false,\"allowrate\":false,\"x\":490,\"y\":2360,\"wires\":[[\"538a3ccd51affbb3\"]]}] You may want to check also the value of MAX temperature register (flow 5) Note Don\u00b4t forget to trigger a manual measurement (flow 3) first time after programming auto measurement. In my testing the MAX temperature reached nearly 57\u00ba celsius.","title":"Playing with the heater"},{"location":"i2c/","text":"I2C-bus library The library i2c-bus available in NPM will empower us to read and write to the registers of the HDC2080. Using Node.js libraries is easier then ever. As from Node-RED 1.3 it is possible to require a Node.js library from inside a function node. All you need to do is declare the library name and the variable name in the setup tab of the function node.","title":"i2C library"},{"location":"i2c/#i2c-bus-library","text":"The library i2c-bus available in NPM will empower us to read and write to the registers of the HDC2080. Using Node.js libraries is easier then ever. As from Node-RED 1.3 it is possible to require a Node.js library from inside a function node. All you need to do is declare the library name and the variable name in the setup tab of the function node.","title":"I2C-bus library"},{"location":"interruptpin/","text":"Handling the interrupt enable pin The interrupt pin is useful to signal that a new measurement is available. You can also configure it to warn temperature or humidity thresholds. Let's make a flow to show this working. We want that the interrupt pin inform us when a new measurement is available. For that purpose we will have to play with the interrupt enable register 0x07. Note Do not confuse the interrupt enable register 0x07 with the interrupt status register 0x04. They are related but are used for different purposes. As usual, we want to have a function node to read the value of the register before we go and change it. Below the flow for you to copy and import to Node-RED. [{\"id\":\"96b572ada0aa82ba\",\"type\":\"comment\",\"z\":\"ae40d2da42dfdbb2\",\"name\":\"Flow 7 : Read the interrupt enable register\",\"info\":\"\",\"x\":260,\"y\":1500,\"wires\":[]},{\"id\":\"b1b6eaaeb69dd864\",\"type\":\"inject\",\"z\":\"ae40d2da42dfdbb2\",\"name\":\"Click to run\",\"props\":[{\"p\":\"payload\"},{\"p\":\"topic\",\"vt\":\"str\"}],\"repeat\":\"\",\"crontab\":\"\",\"once\":false,\"onceDelay\":0.1,\"topic\":\"\",\"payloadType\":\"date\",\"x\":180,\"y\":1560,\"wires\":[[\"afc545b7f11c3b0d\"]]},{\"id\":\"afc545b7f11c3b0d\",\"type\":\"function\",\"z\":\"ae40d2da42dfdbb2\",\"name\":\"Read interrupt enable register\",\"func\":\"const HDC2080_I2C = 0x40;\\n\\nconst hdc = i2c.openSync(1);\\nlet r1 = hdc.readByteSync(HDC2080_I2C, 0x07);\\nhdc.closeSync();\\n\\nmsg.payload = \\\"0x\\\" + r1.toString(16).padStart(2, '0');\\nreturn msg;\",\"outputs\":1,\"noerr\":0,\"initialize\":\"\",\"finalize\":\"\",\"libs\":[{\"var\":\"i2c\",\"module\":\"i2c-bus\"}],\"x\":410,\"y\":1560,\"wires\":[[\"6ed64a45ebcf5635\"]]},{\"id\":\"6ed64a45ebcf5635\",\"type\":\"debug\",\"z\":\"ae40d2da42dfdbb2\",\"name\":\"Debug flow7\",\"active\":true,\"tosidebar\":true,\"console\":false,\"tostatus\":false,\"complete\":\"payload\",\"targetType\":\"msg\",\"statusVal\":\"\",\"statusType\":\"auto\",\"x\":640,\"y\":1560,\"wires\":[]}] Flow: Now let\u00b4s build a function node to write to the interrupt enable pin. Below the flow for you to copy and import to Node-RED. [{\"id\":\"5b6c3e16bba31549\",\"type\":\"inject\",\"z\":\"ae40d2da42dfdbb2\",\"name\":\"Click to run\",\"props\":[{\"p\":\"payload\"},{\"p\":\"topic\",\"vt\":\"str\"}],\"repeat\":\"\",\"crontab\":\"\",\"once\":false,\"onceDelay\":0.1,\"topic\":\"\",\"payloadType\":\"date\",\"x\":180,\"y\":1740,\"wires\":[[\"cc0c715c69b9385f\"]]},{\"id\":\"773cc86a0a24624a\",\"type\":\"comment\",\"z\":\"ae40d2da42dfdbb2\",\"name\":\"Flow 7 : Write value 0x80 to interrupt enable register\",\"info\":\"\",\"x\":290,\"y\":1680,\"wires\":[]},{\"id\":\"cc0c715c69b9385f\",\"type\":\"function\",\"z\":\"ae40d2da42dfdbb2\",\"name\":\"Write interrupt enable register\",\"func\":\"const HDC2080_I2C = 0x40;\\n\\nconst hdc = i2c.openSync(1);\\nhdc.writeByteSync(HDC2080_I2C, 0x07, 0x80);\\nhdc.closeSync();\\n\\nmsg.payload = \\\"0x80\\\";\\nreturn msg;\",\"outputs\":1,\"noerr\":0,\"initialize\":\"\",\"finalize\":\"\",\"libs\":[{\"var\":\"i2c\",\"module\":\"i2c-bus\"}],\"x\":410,\"y\":1740,\"wires\":[[\"9b9077d8f2270c52\"]]},{\"id\":\"9b9077d8f2270c52\",\"type\":\"debug\",\"z\":\"ae40d2da42dfdbb2\",\"name\":\"Debug flow7\",\"active\":true,\"tosidebar\":true,\"console\":false,\"tostatus\":false,\"complete\":\"payload\",\"targetType\":\"msg\",\"statusVal\":\"\",\"statusType\":\"auto\",\"x\":650,\"y\":1740,\"wires\":[]}] Flow: We are done with coding. When you click the inject node in the last flow you are programming the interrupt pin in the device as a data-ready indicator. Now, every time you trigger an i2C measurement this pin will change from low to high. If it is already in high level and you trigger a new measurement you won\u00b4t perceive any change as it remains in high level. When you got a chance an read the temperature or humidity the pin will change from high to low. It would be fun to add a LED to the pin so you can see it visually, in the real-world. Let\u00b4s however add a virtual indicator in the debug panel in Node-RED. But let\u00b4s do this in the next session of this tutorial.","title":"Handling the interrupt pin"},{"location":"interruptpin/#handling-the-interrupt-enable-pin","text":"The interrupt pin is useful to signal that a new measurement is available. You can also configure it to warn temperature or humidity thresholds. Let's make a flow to show this working. We want that the interrupt pin inform us when a new measurement is available. For that purpose we will have to play with the interrupt enable register 0x07. Note Do not confuse the interrupt enable register 0x07 with the interrupt status register 0x04. They are related but are used for different purposes. As usual, we want to have a function node to read the value of the register before we go and change it. Below the flow for you to copy and import to Node-RED. [{\"id\":\"96b572ada0aa82ba\",\"type\":\"comment\",\"z\":\"ae40d2da42dfdbb2\",\"name\":\"Flow 7 : Read the interrupt enable register\",\"info\":\"\",\"x\":260,\"y\":1500,\"wires\":[]},{\"id\":\"b1b6eaaeb69dd864\",\"type\":\"inject\",\"z\":\"ae40d2da42dfdbb2\",\"name\":\"Click to run\",\"props\":[{\"p\":\"payload\"},{\"p\":\"topic\",\"vt\":\"str\"}],\"repeat\":\"\",\"crontab\":\"\",\"once\":false,\"onceDelay\":0.1,\"topic\":\"\",\"payloadType\":\"date\",\"x\":180,\"y\":1560,\"wires\":[[\"afc545b7f11c3b0d\"]]},{\"id\":\"afc545b7f11c3b0d\",\"type\":\"function\",\"z\":\"ae40d2da42dfdbb2\",\"name\":\"Read interrupt enable register\",\"func\":\"const HDC2080_I2C = 0x40;\\n\\nconst hdc = i2c.openSync(1);\\nlet r1 = hdc.readByteSync(HDC2080_I2C, 0x07);\\nhdc.closeSync();\\n\\nmsg.payload = \\\"0x\\\" + r1.toString(16).padStart(2, '0');\\nreturn msg;\",\"outputs\":1,\"noerr\":0,\"initialize\":\"\",\"finalize\":\"\",\"libs\":[{\"var\":\"i2c\",\"module\":\"i2c-bus\"}],\"x\":410,\"y\":1560,\"wires\":[[\"6ed64a45ebcf5635\"]]},{\"id\":\"6ed64a45ebcf5635\",\"type\":\"debug\",\"z\":\"ae40d2da42dfdbb2\",\"name\":\"Debug flow7\",\"active\":true,\"tosidebar\":true,\"console\":false,\"tostatus\":false,\"complete\":\"payload\",\"targetType\":\"msg\",\"statusVal\":\"\",\"statusType\":\"auto\",\"x\":640,\"y\":1560,\"wires\":[]}] Flow: Now let\u00b4s build a function node to write to the interrupt enable pin. Below the flow for you to copy and import to Node-RED. [{\"id\":\"5b6c3e16bba31549\",\"type\":\"inject\",\"z\":\"ae40d2da42dfdbb2\",\"name\":\"Click to run\",\"props\":[{\"p\":\"payload\"},{\"p\":\"topic\",\"vt\":\"str\"}],\"repeat\":\"\",\"crontab\":\"\",\"once\":false,\"onceDelay\":0.1,\"topic\":\"\",\"payloadType\":\"date\",\"x\":180,\"y\":1740,\"wires\":[[\"cc0c715c69b9385f\"]]},{\"id\":\"773cc86a0a24624a\",\"type\":\"comment\",\"z\":\"ae40d2da42dfdbb2\",\"name\":\"Flow 7 : Write value 0x80 to interrupt enable register\",\"info\":\"\",\"x\":290,\"y\":1680,\"wires\":[]},{\"id\":\"cc0c715c69b9385f\",\"type\":\"function\",\"z\":\"ae40d2da42dfdbb2\",\"name\":\"Write interrupt enable register\",\"func\":\"const HDC2080_I2C = 0x40;\\n\\nconst hdc = i2c.openSync(1);\\nhdc.writeByteSync(HDC2080_I2C, 0x07, 0x80);\\nhdc.closeSync();\\n\\nmsg.payload = \\\"0x80\\\";\\nreturn msg;\",\"outputs\":1,\"noerr\":0,\"initialize\":\"\",\"finalize\":\"\",\"libs\":[{\"var\":\"i2c\",\"module\":\"i2c-bus\"}],\"x\":410,\"y\":1740,\"wires\":[[\"9b9077d8f2270c52\"]]},{\"id\":\"9b9077d8f2270c52\",\"type\":\"debug\",\"z\":\"ae40d2da42dfdbb2\",\"name\":\"Debug flow7\",\"active\":true,\"tosidebar\":true,\"console\":false,\"tostatus\":false,\"complete\":\"payload\",\"targetType\":\"msg\",\"statusVal\":\"\",\"statusType\":\"auto\",\"x\":650,\"y\":1740,\"wires\":[]}] Flow: We are done with coding. When you click the inject node in the last flow you are programming the interrupt pin in the device as a data-ready indicator. Now, every time you trigger an i2C measurement this pin will change from low to high. If it is already in high level and you trigger a new measurement you won\u00b4t perceive any change as it remains in high level. When you got a chance an read the temperature or humidity the pin will change from high to low. It would be fun to add a LED to the pin so you can see it visually, in the real-world. Let\u00b4s however add a virtual indicator in the debug panel in Node-RED. But let\u00b4s do this in the next session of this tutorial.","title":"Handling the interrupt enable pin"},{"location":"interruptregisters/","text":"Interrupt registers Interrupt status register (0x04) The bits in this register will show whether new measurements exist or show temperature and humidity thresholds. Interrupt configuration register (0x07) Here is another important register even if it is used only once in the lifecycle of your project. This register will determine which value the interrupt pin will track. In our case, as we want to track new temperature and humidity values, we will use it as data ready pin. You can however use it to signal humidity and temperatue thresholds. Note Some restrictions apply to the use of the interrupt pin. It can only track one : new measurement or threshold. It can't track temperature threshold and, at the same time, humidity threshold. A priority rule will dictate the device way of working in case you configure more than one threshold. Here below the excerpt of the datasheet that explains the priority rule:","title":"Interrupt registers"},{"location":"interruptregisters/#interrupt-registers","text":"","title":"Interrupt registers"},{"location":"interruptregisters/#interrupt-status-register-0x04","text":"The bits in this register will show whether new measurements exist or show temperature and humidity thresholds.","title":"Interrupt status register (0x04)"},{"location":"interruptregisters/#interrupt-configuration-register-0x07","text":"Here is another important register even if it is used only once in the lifecycle of your project. This register will determine which value the interrupt pin will track. In our case, as we want to track new temperature and humidity values, we will use it as data ready pin. You can however use it to signal humidity and temperatue thresholds. Note Some restrictions apply to the use of the interrupt pin. It can only track one : new measurement or threshold. It can't track temperature threshold and, at the same time, humidity threshold. A priority rule will dictate the device way of working in case you configure more than one threshold. Here below the excerpt of the datasheet that explains the priority rule:","title":"Interrupt configuration register (0x07)"},{"location":"measurementregister/","text":"Measurement register (0x0F) I will only briefly mention this register but it is crucial for this tutorial. There is one bit in this register that will trigger a measurement via I2C when it is set to value one. We will configure later a Node-RED node to set this bit whenever we want to force the HDC2080 to generate and store a new measurement. Note that this register allows also to configure the resolution of our measurements but we will not touch this configuration as we always want to work with the most precise resolution of 14 bits. This is as simple as writing the value 0x01 to the register.","title":"Measurement register"},{"location":"measurementregister/#measurement-register-0x0f","text":"I will only briefly mention this register but it is crucial for this tutorial. There is one bit in this register that will trigger a measurement via I2C when it is set to value one. We will configure later a Node-RED node to set this bit whenever we want to force the HDC2080 to generate and store a new measurement. Note that this register allows also to configure the resolution of our measurements but we will not touch this configuration as we always want to work with the most precise resolution of 14 bits. This is as simple as writing the value 0x01 to the register.","title":"Measurement register (0x0F)"},{"location":"playingautomeasurement/","text":"Playing with auto measurement Auto measurement is a nice feature. Let's give it a chance. How about generating a new measurement every 10 seconds ? For that purpose we need to setup the configuration register 0x0E with the value 0x36. 0x36 = 0011 0110 bit 7 = 0 , normal operation (instead of reset mode) bits 6,5,4 = 011 = 1 sample every 10 seconds bit 3 = 0, heater off bit 2 = 1, interrupt pin enabled bit 1 = 1, interrupt active high bit 0 = 0, interrupt mode level sensitive This is the code inside the function node: const HDC2080_I2C = 0x40; const hdc = i2c.openSync(1); hdc.writeByteSync(HDC2080_I2C, 0x0E, 0x36); hdc.closeSync(); msg.payload = \"0x36\"; return msg; Below the flow for you to copy and import to Node-RED. [{\"id\":\"fced05ac8073f868\",\"type\":\"comment\",\"z\":\"ae40d2da42dfdbb2\",\"name\":\"1 readng every 10 seconds\",\"info\":\"\",\"x\":210,\"y\":2040,\"wires\":[]},{\"id\":\"5c8a65ea991b187c\",\"type\":\"inject\",\"z\":\"ae40d2da42dfdbb2\",\"name\":\"Click to run\",\"props\":[{\"p\":\"payload\"},{\"p\":\"topic\",\"vt\":\"str\"}],\"repeat\":\"\",\"crontab\":\"\",\"once\":false,\"onceDelay\":0.1,\"topic\":\"\",\"payloadType\":\"date\",\"x\":180,\"y\":2100,\"wires\":[[\"b01133b39caa746c\"]]},{\"id\":\"b01133b39caa746c\",\"type\":\"function\",\"z\":\"ae40d2da42dfdbb2\",\"name\":\"1 reading every 10 seconds\",\"func\":\"const HDC2080_I2C = 0x40;\\n\\nconst hdc = i2c.openSync(1);\\nhdc.writeByteSync(HDC2080_I2C, 0x0E, 0x36);\\nhdc.closeSync();\\n\\nmsg.payload = \\\"0x36\\\";\\nreturn msg;\",\"outputs\":1,\"noerr\":0,\"initialize\":\"\",\"finalize\":\"\",\"libs\":[{\"var\":\"i2c\",\"module\":\"i2c-bus\"}],\"x\":400,\"y\":2100,\"wires\":[[\"020cd089a072125c\"]]},{\"id\":\"020cd089a072125c\",\"type\":\"debug\",\"z\":\"ae40d2da42dfdbb2\",\"name\":\"Debuf flow8\",\"active\":true,\"tosidebar\":true,\"console\":false,\"tostatus\":false,\"complete\":\"payload\",\"targetType\":\"msg\",\"statusVal\":\"\",\"statusType\":\"auto\",\"x\":630,\"y\":2100,\"wires\":[]}] Here a printscreen of the flow: Note Auto measurement will not start until you trigger a measurement (Flow 3 : Trigger measurement via I2C) a first time. The next measurements will be automatic at the programmed pace of 1 sample every 10 seconds.","title":"Playing with auto measurement"},{"location":"playingautomeasurement/#playing-with-auto-measurement","text":"Auto measurement is a nice feature. Let's give it a chance. How about generating a new measurement every 10 seconds ? For that purpose we need to setup the configuration register 0x0E with the value 0x36. 0x36 = 0011 0110 bit 7 = 0 , normal operation (instead of reset mode) bits 6,5,4 = 011 = 1 sample every 10 seconds bit 3 = 0, heater off bit 2 = 1, interrupt pin enabled bit 1 = 1, interrupt active high bit 0 = 0, interrupt mode level sensitive This is the code inside the function node: const HDC2080_I2C = 0x40; const hdc = i2c.openSync(1); hdc.writeByteSync(HDC2080_I2C, 0x0E, 0x36); hdc.closeSync(); msg.payload = \"0x36\"; return msg; Below the flow for you to copy and import to Node-RED. [{\"id\":\"fced05ac8073f868\",\"type\":\"comment\",\"z\":\"ae40d2da42dfdbb2\",\"name\":\"1 readng every 10 seconds\",\"info\":\"\",\"x\":210,\"y\":2040,\"wires\":[]},{\"id\":\"5c8a65ea991b187c\",\"type\":\"inject\",\"z\":\"ae40d2da42dfdbb2\",\"name\":\"Click to run\",\"props\":[{\"p\":\"payload\"},{\"p\":\"topic\",\"vt\":\"str\"}],\"repeat\":\"\",\"crontab\":\"\",\"once\":false,\"onceDelay\":0.1,\"topic\":\"\",\"payloadType\":\"date\",\"x\":180,\"y\":2100,\"wires\":[[\"b01133b39caa746c\"]]},{\"id\":\"b01133b39caa746c\",\"type\":\"function\",\"z\":\"ae40d2da42dfdbb2\",\"name\":\"1 reading every 10 seconds\",\"func\":\"const HDC2080_I2C = 0x40;\\n\\nconst hdc = i2c.openSync(1);\\nhdc.writeByteSync(HDC2080_I2C, 0x0E, 0x36);\\nhdc.closeSync();\\n\\nmsg.payload = \\\"0x36\\\";\\nreturn msg;\",\"outputs\":1,\"noerr\":0,\"initialize\":\"\",\"finalize\":\"\",\"libs\":[{\"var\":\"i2c\",\"module\":\"i2c-bus\"}],\"x\":400,\"y\":2100,\"wires\":[[\"020cd089a072125c\"]]},{\"id\":\"020cd089a072125c\",\"type\":\"debug\",\"z\":\"ae40d2da42dfdbb2\",\"name\":\"Debuf flow8\",\"active\":true,\"tosidebar\":true,\"console\":false,\"tostatus\":false,\"complete\":\"payload\",\"targetType\":\"msg\",\"statusVal\":\"\",\"statusType\":\"auto\",\"x\":630,\"y\":2100,\"wires\":[]}] Here a printscreen of the flow: Note Auto measurement will not start until you trigger a measurement (Flow 3 : Trigger measurement via I2C) a first time. The next measurements will be automatic at the programmed pace of 1 sample every 10 seconds.","title":"Playing with auto measurement"},{"location":"reading/","text":"Reading temperature and humidity How to get humidity and temperature values The sensor will remain in sleep mode until a measurement is triggered. There is a set of three bits in the registers that will tell the sensor to work in auto measurements mode or wait for an I2C command to trigger a single measurement. The values of the measurement are converted from analog to digital and stored in specific registers from where you can read the values. It is possible to configure the sensor to signal in the physical interrupt pin the availability of new measurements. Reading temperature Temperature is stored by the sensor in registers 0x00 and 0x01. Register 0x00 holds the least significant bits (bits0 to 7) and 0x01 the most significant bits (bits 8 to 15). As a matter of fact only 14 bits are used but this won\u00b4t change how you read the value. As the measurement value is stored in two 8-byte registers you have a couple of ways to get it. The first alternative is programming your computer or microcontroller to read two consecutive bytes. First read the register 0x00 and then read register 0x01. The other alternative is reading both registers in a single shot as a 16 bit word. Whatever is the way you get the value it is necessary to apply a formula afterward to make sense of the value. Temperature is translated to degrees centigrade. In JavaScript this formula can be written as below if you read the registers as byte values: msg.payload = (((256 * r2) + r1) / 65536) * 165 - 40.5; where r1 is the reading of the least significant value and r2 the reading of the most significant value. Now, if you read a single 16 bit value then you want to use a slightly different formula: msg.payload = (r / 65536) * 165 - 40.5; where r is the 16 bit value. Reading humidity It is almost the same in regards to reading humidity values but in this case you will get the values form registers 0x02 (least significant) and 0x03 (most significant). The formula to apply, according to the datasheet is: Humidity is given as a percentage. In JavaScript this formula can be written as below if you read the registers as byte values: msg.payload = (((256 * r2) + r1) / 65536) * 100; where r1 is the reading of the least significant value and r2 the reading of the most significant value. Likewise, the formula for humidity when you read the registers as a 16 bit value: msg.payload = r / 65536 * 100; One nice feature of the HDC2080 is that it can be used as a data logger for maximum values of temperature and humidity. These maximum values are stored in internal registers. This is available only for measurements triggered by I2C readings (will not work for auto measurement).","title":"Reading humidity and temperature"},{"location":"reading/#reading-temperature-and-humidity","text":"","title":"Reading temperature and humidity"},{"location":"reading/#how-to-get-humidity-and-temperature-values","text":"The sensor will remain in sleep mode until a measurement is triggered. There is a set of three bits in the registers that will tell the sensor to work in auto measurements mode or wait for an I2C command to trigger a single measurement. The values of the measurement are converted from analog to digital and stored in specific registers from where you can read the values. It is possible to configure the sensor to signal in the physical interrupt pin the availability of new measurements.","title":"How to get humidity and temperature values"},{"location":"reading/#reading-temperature","text":"Temperature is stored by the sensor in registers 0x00 and 0x01. Register 0x00 holds the least significant bits (bits0 to 7) and 0x01 the most significant bits (bits 8 to 15). As a matter of fact only 14 bits are used but this won\u00b4t change how you read the value. As the measurement value is stored in two 8-byte registers you have a couple of ways to get it. The first alternative is programming your computer or microcontroller to read two consecutive bytes. First read the register 0x00 and then read register 0x01. The other alternative is reading both registers in a single shot as a 16 bit word. Whatever is the way you get the value it is necessary to apply a formula afterward to make sense of the value. Temperature is translated to degrees centigrade. In JavaScript this formula can be written as below if you read the registers as byte values: msg.payload = (((256 * r2) + r1) / 65536) * 165 - 40.5; where r1 is the reading of the least significant value and r2 the reading of the most significant value. Now, if you read a single 16 bit value then you want to use a slightly different formula: msg.payload = (r / 65536) * 165 - 40.5; where r is the 16 bit value.","title":"Reading temperature"},{"location":"reading/#reading-humidity","text":"It is almost the same in regards to reading humidity values but in this case you will get the values form registers 0x02 (least significant) and 0x03 (most significant). The formula to apply, according to the datasheet is: Humidity is given as a percentage. In JavaScript this formula can be written as below if you read the registers as byte values: msg.payload = (((256 * r2) + r1) / 65536) * 100; where r1 is the reading of the least significant value and r2 the reading of the most significant value. Likewise, the formula for humidity when you read the registers as a 16 bit value: msg.payload = r / 65536 * 100; One nice feature of the HDC2080 is that it can be used as a data logger for maximum values of temperature and humidity. These maximum values are stored in internal registers. This is available only for measurements triggered by I2C readings (will not work for auto measurement).","title":"Reading humidity"},{"location":"readingall/","text":"Reading all registers So far we developed flows to perform simple read and write operations. Let's now raise the bar and do some more advance stuff. Something that looks useful is reading all registers at once. This may allow us to visualise in an easier way how the HDC2080 is configured. Reading all registers at once takes a bit more time than doing a simple read, so I thought it would be a good idea to use async code for this reading. This is the code we will use inside the function node: const HDC2080_I2C = 0x40; let tem =0; const hdc = i2c.openSync(1); hdc.readWord(HDC2080_I2C, 0x00, (a,b) => {node.send({topic : \"0x00\", payload : b}) }); hdc.readWord(HDC2080_I2C, 0x02, (a,b) => {node.send({topic : \"0x02\", payload : b}) }); hdc.readByte(HDC2080_I2C, 0x04, (a,b) => {node.send({topic : \"0x04\", payload : b}) }); hdc.readByte(HDC2080_I2C, 0x05, (a,b) => {node.send({topic : \"0x05\", payload : b}) }); hdc.readByte(HDC2080_I2C, 0x06, (a,b) => {node.send({topic : \"0x06\", payload : b}) }); hdc.readByte(HDC2080_I2C, 0x07, (a,b) => {node.send({topic : \"0x07\", payload : b}) }); hdc.readByte(HDC2080_I2C, 0x08, (a,b) => {node.send({topic : \"0x08\", payload : b}) }); hdc.readByte(HDC2080_I2C, 0x09, (a,b) => {node.send({topic : \"0x09\", payload : b}) }); hdc.readByte(HDC2080_I2C, 0x0A, (a,b) => {node.send({topic : \"0x0A\", payload : b}) }); hdc.readByte(HDC2080_I2C, 0x0B, (a,b) => {node.send({topic : \"0x0B\", payload : b}) }); hdc.readByte(HDC2080_I2C, 0x0C, (a,b) => {node.send({topic : \"0x0C\", payload : b}) }); hdc.readByte(HDC2080_I2C, 0x0D, (a,b) => {node.send({topic : \"0x0D\", payload : b}) }); hdc.readByte(HDC2080_I2C, 0x0E, (a,b) => {node.send({topic : \"0x0E\", payload : b}) }); hdc.readByte(HDC2080_I2C, 0x0F, (a,b) => {node.send({topic : \"0x0F\", payload : b}) }); hdc.readWord(HDC2080_I2C, 0xFC, (a,b) => {node.send({topic : \"0xFC\", payload : b}) }); hdc.readWord(HDC2080_I2C, 0xFE, (a,b) => {node.send({topic : \"0xFE\", payload : b}) }); hdc.closeSync(); and this is the flow: Below the flow for you to copy and import to Node-RED. [{\"id\":\"6c5ca181329200ab\",\"type\":\"function\",\"z\":\"ae40d2da42dfdbb2\",\"name\":\"Read ALL registers\",\"func\":\"const HDC2080_I2C = 0x40;\\nlet tem =0;\\n\\nconst hdc = i2c.openSync(1);\\nhdc.readWord(HDC2080_I2C, 0x00, (a,b) => {node.send({topic : \\\"0x00\\\", payload : b}) });\\nhdc.readWord(HDC2080_I2C, 0x02, (a,b) => {node.send({topic : \\\"0x02\\\", payload : b}) });\\n\\nhdc.readByte(HDC2080_I2C, 0x04, (a,b) => {node.send({topic : \\\"0x04\\\", payload : b}) });\\nhdc.readByte(HDC2080_I2C, 0x05, (a,b) => {node.send({topic : \\\"0x05\\\", payload : b}) });\\nhdc.readByte(HDC2080_I2C, 0x06, (a,b) => {node.send({topic : \\\"0x06\\\", payload : b}) });\\nhdc.readByte(HDC2080_I2C, 0x07, (a,b) => {node.send({topic : \\\"0x07\\\", payload : b}) });\\nhdc.readByte(HDC2080_I2C, 0x08, (a,b) => {node.send({topic : \\\"0x08\\\", payload : b}) });\\nhdc.readByte(HDC2080_I2C, 0x09, (a,b) => {node.send({topic : \\\"0x09\\\", payload : b}) });\\nhdc.readByte(HDC2080_I2C, 0x0A, (a,b) => {node.send({topic : \\\"0x0A\\\", payload : b}) });\\nhdc.readByte(HDC2080_I2C, 0x0B, (a,b) => {node.send({topic : \\\"0x0B\\\", payload : b}) });\\nhdc.readByte(HDC2080_I2C, 0x0C, (a,b) => {node.send({topic : \\\"0x0C\\\", payload : b}) });\\nhdc.readByte(HDC2080_I2C, 0x0D, (a,b) => {node.send({topic : \\\"0x0D\\\", payload : b}) });\\nhdc.readByte(HDC2080_I2C, 0x0E, (a,b) => {node.send({topic : \\\"0x0E\\\", payload : b}) });\\nhdc.readByte(HDC2080_I2C, 0x0F, (a,b) => {node.send({topic : \\\"0x0F\\\", payload : b}) });\\n\\nhdc.readWord(HDC2080_I2C, 0xFC, (a,b) => {node.send({topic : \\\"0xFC\\\", payload : b}) });\\nhdc.readWord(HDC2080_I2C, 0xFE, (a,b) => {node.send({topic : \\\"0xFE\\\", payload : b}) });\\nhdc.closeSync();\\n\\n\",\"outputs\":1,\"noerr\":0,\"initialize\":\"\",\"finalize\":\"\",\"libs\":[{\"var\":\"i2c\",\"module\":\"i2c-bus\"}],\"x\":370,\"y\":2580,\"wires\":[[\"3795045389336255\"]]},{\"id\":\"ee49d6b4a9ef1dbb\",\"type\":\"inject\",\"z\":\"ae40d2da42dfdbb2\",\"name\":\"Click to run\",\"props\":[{\"p\":\"payload\"},{\"p\":\"topic\",\"vt\":\"str\"}],\"repeat\":\"\",\"crontab\":\"\",\"once\":false,\"onceDelay\":0.1,\"topic\":\"\",\"payloadType\":\"date\",\"x\":190,\"y\":2580,\"wires\":[[\"6c5ca181329200ab\"]]},{\"id\":\"ba081be2210e5f29\",\"type\":\"debug\",\"z\":\"ae40d2da42dfdbb2\",\"name\":\"Debug flow10\",\"active\":true,\"tosidebar\":true,\"console\":false,\"tostatus\":false,\"complete\":\"true\",\"targetType\":\"full\",\"statusVal\":\"\",\"statusType\":\"auto\",\"x\":760,\"y\":2580,\"wires\":[]},{\"id\":\"3795045389336255\",\"type\":\"change\",\"z\":\"ae40d2da42dfdbb2\",\"name\":\"Build topic name\",\"rules\":[{\"t\":\"set\",\"p\":\"topic\",\"pt\":\"msg\",\"to\":\"\\\"hdc2080/\\\"&topic\",\"tot\":\"jsonata\"}],\"action\":\"\",\"property\":\"\",\"from\":\"\",\"to\":\"\",\"reg\":false,\"x\":560,\"y\":2580,\"wires\":[[\"ba081be2210e5f29\"]]},{\"id\":\"77fcf407fe55a350\",\"type\":\"comment\",\"z\":\"ae40d2da42dfdbb2\",\"name\":\"Flow 10 - Read all registers async reading\",\"info\":\"\",\"x\":260,\"y\":2520,\"wires\":[]}] It will generate and send one object for each register. The payload holds the value of the register whereas the topic indicates the register address. You can configure the topic name in the change node that is connected to the function node. What I like most in this flow is that it can be used along MQTT to information from the sensor to some centralized monitoring and dashboard. When you run the flow you will see the flow of data in the debug node.","title":"Reading all registers"},{"location":"readingall/#reading-all-registers","text":"So far we developed flows to perform simple read and write operations. Let's now raise the bar and do some more advance stuff. Something that looks useful is reading all registers at once. This may allow us to visualise in an easier way how the HDC2080 is configured. Reading all registers at once takes a bit more time than doing a simple read, so I thought it would be a good idea to use async code for this reading. This is the code we will use inside the function node: const HDC2080_I2C = 0x40; let tem =0; const hdc = i2c.openSync(1); hdc.readWord(HDC2080_I2C, 0x00, (a,b) => {node.send({topic : \"0x00\", payload : b}) }); hdc.readWord(HDC2080_I2C, 0x02, (a,b) => {node.send({topic : \"0x02\", payload : b}) }); hdc.readByte(HDC2080_I2C, 0x04, (a,b) => {node.send({topic : \"0x04\", payload : b}) }); hdc.readByte(HDC2080_I2C, 0x05, (a,b) => {node.send({topic : \"0x05\", payload : b}) }); hdc.readByte(HDC2080_I2C, 0x06, (a,b) => {node.send({topic : \"0x06\", payload : b}) }); hdc.readByte(HDC2080_I2C, 0x07, (a,b) => {node.send({topic : \"0x07\", payload : b}) }); hdc.readByte(HDC2080_I2C, 0x08, (a,b) => {node.send({topic : \"0x08\", payload : b}) }); hdc.readByte(HDC2080_I2C, 0x09, (a,b) => {node.send({topic : \"0x09\", payload : b}) }); hdc.readByte(HDC2080_I2C, 0x0A, (a,b) => {node.send({topic : \"0x0A\", payload : b}) }); hdc.readByte(HDC2080_I2C, 0x0B, (a,b) => {node.send({topic : \"0x0B\", payload : b}) }); hdc.readByte(HDC2080_I2C, 0x0C, (a,b) => {node.send({topic : \"0x0C\", payload : b}) }); hdc.readByte(HDC2080_I2C, 0x0D, (a,b) => {node.send({topic : \"0x0D\", payload : b}) }); hdc.readByte(HDC2080_I2C, 0x0E, (a,b) => {node.send({topic : \"0x0E\", payload : b}) }); hdc.readByte(HDC2080_I2C, 0x0F, (a,b) => {node.send({topic : \"0x0F\", payload : b}) }); hdc.readWord(HDC2080_I2C, 0xFC, (a,b) => {node.send({topic : \"0xFC\", payload : b}) }); hdc.readWord(HDC2080_I2C, 0xFE, (a,b) => {node.send({topic : \"0xFE\", payload : b}) }); hdc.closeSync(); and this is the flow: Below the flow for you to copy and import to Node-RED. [{\"id\":\"6c5ca181329200ab\",\"type\":\"function\",\"z\":\"ae40d2da42dfdbb2\",\"name\":\"Read ALL registers\",\"func\":\"const HDC2080_I2C = 0x40;\\nlet tem =0;\\n\\nconst hdc = i2c.openSync(1);\\nhdc.readWord(HDC2080_I2C, 0x00, (a,b) => {node.send({topic : \\\"0x00\\\", payload : b}) });\\nhdc.readWord(HDC2080_I2C, 0x02, (a,b) => {node.send({topic : \\\"0x02\\\", payload : b}) });\\n\\nhdc.readByte(HDC2080_I2C, 0x04, (a,b) => {node.send({topic : \\\"0x04\\\", payload : b}) });\\nhdc.readByte(HDC2080_I2C, 0x05, (a,b) => {node.send({topic : \\\"0x05\\\", payload : b}) });\\nhdc.readByte(HDC2080_I2C, 0x06, (a,b) => {node.send({topic : \\\"0x06\\\", payload : b}) });\\nhdc.readByte(HDC2080_I2C, 0x07, (a,b) => {node.send({topic : \\\"0x07\\\", payload : b}) });\\nhdc.readByte(HDC2080_I2C, 0x08, (a,b) => {node.send({topic : \\\"0x08\\\", payload : b}) });\\nhdc.readByte(HDC2080_I2C, 0x09, (a,b) => {node.send({topic : \\\"0x09\\\", payload : b}) });\\nhdc.readByte(HDC2080_I2C, 0x0A, (a,b) => {node.send({topic : \\\"0x0A\\\", payload : b}) });\\nhdc.readByte(HDC2080_I2C, 0x0B, (a,b) => {node.send({topic : \\\"0x0B\\\", payload : b}) });\\nhdc.readByte(HDC2080_I2C, 0x0C, (a,b) => {node.send({topic : \\\"0x0C\\\", payload : b}) });\\nhdc.readByte(HDC2080_I2C, 0x0D, (a,b) => {node.send({topic : \\\"0x0D\\\", payload : b}) });\\nhdc.readByte(HDC2080_I2C, 0x0E, (a,b) => {node.send({topic : \\\"0x0E\\\", payload : b}) });\\nhdc.readByte(HDC2080_I2C, 0x0F, (a,b) => {node.send({topic : \\\"0x0F\\\", payload : b}) });\\n\\nhdc.readWord(HDC2080_I2C, 0xFC, (a,b) => {node.send({topic : \\\"0xFC\\\", payload : b}) });\\nhdc.readWord(HDC2080_I2C, 0xFE, (a,b) => {node.send({topic : \\\"0xFE\\\", payload : b}) });\\nhdc.closeSync();\\n\\n\",\"outputs\":1,\"noerr\":0,\"initialize\":\"\",\"finalize\":\"\",\"libs\":[{\"var\":\"i2c\",\"module\":\"i2c-bus\"}],\"x\":370,\"y\":2580,\"wires\":[[\"3795045389336255\"]]},{\"id\":\"ee49d6b4a9ef1dbb\",\"type\":\"inject\",\"z\":\"ae40d2da42dfdbb2\",\"name\":\"Click to run\",\"props\":[{\"p\":\"payload\"},{\"p\":\"topic\",\"vt\":\"str\"}],\"repeat\":\"\",\"crontab\":\"\",\"once\":false,\"onceDelay\":0.1,\"topic\":\"\",\"payloadType\":\"date\",\"x\":190,\"y\":2580,\"wires\":[[\"6c5ca181329200ab\"]]},{\"id\":\"ba081be2210e5f29\",\"type\":\"debug\",\"z\":\"ae40d2da42dfdbb2\",\"name\":\"Debug flow10\",\"active\":true,\"tosidebar\":true,\"console\":false,\"tostatus\":false,\"complete\":\"true\",\"targetType\":\"full\",\"statusVal\":\"\",\"statusType\":\"auto\",\"x\":760,\"y\":2580,\"wires\":[]},{\"id\":\"3795045389336255\",\"type\":\"change\",\"z\":\"ae40d2da42dfdbb2\",\"name\":\"Build topic name\",\"rules\":[{\"t\":\"set\",\"p\":\"topic\",\"pt\":\"msg\",\"to\":\"\\\"hdc2080/\\\"&topic\",\"tot\":\"jsonata\"}],\"action\":\"\",\"property\":\"\",\"from\":\"\",\"to\":\"\",\"reg\":false,\"x\":560,\"y\":2580,\"wires\":[[\"ba081be2210e5f29\"]]},{\"id\":\"77fcf407fe55a350\",\"type\":\"comment\",\"z\":\"ae40d2da42dfdbb2\",\"name\":\"Flow 10 - Read all registers async reading\",\"info\":\"\",\"x\":260,\"y\":2520,\"wires\":[]}] It will generate and send one object for each register. The payload holds the value of the register whereas the topic indicates the register address. You can configure the topic name in the change node that is connected to the function node. What I like most in this flow is that it can be used along MQTT to information from the sensor to some centralized monitoring and dashboard. When you run the flow you will see the flow of data in the debug node.","title":"Reading all registers"},{"location":"readingmax/","text":"Reading Max temperature and humidity The HDC2080 has registers that store the peak temperature and humidity values read since the device was powered up. This information could be useful in some use cases. Reading them is pretty easy. Reading Max temperature We read the byte from register 0x05 to get the max temperature. const HDC2080_I2C = 0x40; const hdc = i2c.openSync(1); let r1 = hdc.readByteSync(HDC2080_I2C, 0x05); hdc.closeSync(); msg.payload = (r1 / 256) * 165 - 40.5; return msg; Below the flow for you to copy and import to Node-RED. [{\"id\":\"66512f3e1e0938dc\",\"type\":\"comment\",\"z\":\"ae40d2da42dfdbb2\",\"name\":\"Flow 5 : Read MAX temperature\",\"info\":\"\",\"x\":230,\"y\":1020,\"wires\":[]},{\"id\":\"139778360202aca7\",\"type\":\"inject\",\"z\":\"ae40d2da42dfdbb2\",\"name\":\"Click to run\",\"props\":[{\"p\":\"payload\"},{\"p\":\"topic\",\"vt\":\"str\"}],\"repeat\":\"\",\"crontab\":\"\",\"once\":false,\"onceDelay\":0.1,\"topic\":\"\",\"payloadType\":\"date\",\"x\":180,\"y\":1080,\"wires\":[[\"e4bf6d56a2d1a00f\"]]},{\"id\":\"e4bf6d56a2d1a00f\",\"type\":\"function\",\"z\":\"ae40d2da42dfdbb2\",\"name\":\"Read MAX temperature\",\"func\":\"const HDC2080_I2C = 0x40;\\n\\nconst hdc = i2c.openSync(1);\\nlet r1 = hdc.readByteSync(HDC2080_I2C, 0x05);\\nhdc.closeSync();\\n\\nmsg.payload = (r1 / 256) * 165 - 40.5;\\nreturn msg;\",\"outputs\":1,\"noerr\":0,\"initialize\":\"\",\"finalize\":\"\",\"libs\":[{\"var\":\"i2c\",\"module\":\"i2c-bus\"}],\"x\":390,\"y\":1080,\"wires\":[[\"5f66699f757577b8\"]]},{\"id\":\"5f66699f757577b8\",\"type\":\"debug\",\"z\":\"ae40d2da42dfdbb2\",\"name\":\"Debug flow5\",\"active\":true,\"tosidebar\":true,\"console\":false,\"tostatus\":false,\"complete\":\"payload\",\"targetType\":\"msg\",\"statusVal\":\"\",\"statusType\":\"auto\",\"x\":610,\"y\":1080,\"wires\":[]}] Flow image: Reading Max humidity We read the byte from register 0x06 to get the max humidity. const HDC2080_I2C = 0x40; const hdc = i2c.openSync(1); let r1 = hdc.readByteSync(HDC2080_I2C, 0x06); hdc.closeSync(); msg.payload = (r1 / 256) * 100; return msg; Below the flow for you to copy and import to Node-RED. [{\"id\":\"7acf3202ed2f34ac\",\"type\":\"comment\",\"z\":\"ae40d2da42dfdbb2\",\"name\":\"Flow 5 : Read MAX humidity\",\"info\":\"\",\"x\":220,\"y\":1180,\"wires\":[]},{\"id\":\"cd2f739e240a486b\",\"type\":\"inject\",\"z\":\"ae40d2da42dfdbb2\",\"name\":\"Click to run\",\"props\":[{\"p\":\"payload\"},{\"p\":\"topic\",\"vt\":\"str\"}],\"repeat\":\"\",\"crontab\":\"\",\"once\":false,\"onceDelay\":0.1,\"topic\":\"\",\"payloadType\":\"date\",\"x\":180,\"y\":1240,\"wires\":[[\"9ab0e0e884823fc5\"]]},{\"id\":\"9ab0e0e884823fc5\",\"type\":\"function\",\"z\":\"ae40d2da42dfdbb2\",\"name\":\"Read MAX humidity\",\"func\":\"const HDC2080_I2C = 0x40;\\n\\nconst hdc = i2c.openSync(1);\\nlet r1 = hdc.readByteSync(HDC2080_I2C, 0x06);\\nhdc.closeSync();\\n\\nmsg.payload = (r1 / 256) * 100;\\n\\nreturn msg;\",\"outputs\":1,\"noerr\":0,\"initialize\":\"\",\"finalize\":\"\",\"libs\":[{\"var\":\"i2c\",\"module\":\"i2c-bus\"}],\"x\":380,\"y\":1240,\"wires\":[[\"0f5aca8fc8b1f7a2\"]]},{\"id\":\"0f5aca8fc8b1f7a2\",\"type\":\"debug\",\"z\":\"ae40d2da42dfdbb2\",\"name\":\"Debug flow5\",\"active\":true,\"tosidebar\":true,\"console\":false,\"tostatus\":false,\"complete\":\"payload\",\"targetType\":\"msg\",\"statusVal\":\"\",\"statusType\":\"auto\",\"x\":610,\"y\":1240,\"wires\":[]}] Flow image:","title":"Reading Max temperature and humidity"},{"location":"readingmax/#reading-max-temperature-and-humidity","text":"The HDC2080 has registers that store the peak temperature and humidity values read since the device was powered up. This information could be useful in some use cases. Reading them is pretty easy.","title":"Reading Max temperature and humidity"},{"location":"readingmax/#reading-max-temperature","text":"We read the byte from register 0x05 to get the max temperature. const HDC2080_I2C = 0x40; const hdc = i2c.openSync(1); let r1 = hdc.readByteSync(HDC2080_I2C, 0x05); hdc.closeSync(); msg.payload = (r1 / 256) * 165 - 40.5; return msg; Below the flow for you to copy and import to Node-RED. [{\"id\":\"66512f3e1e0938dc\",\"type\":\"comment\",\"z\":\"ae40d2da42dfdbb2\",\"name\":\"Flow 5 : Read MAX temperature\",\"info\":\"\",\"x\":230,\"y\":1020,\"wires\":[]},{\"id\":\"139778360202aca7\",\"type\":\"inject\",\"z\":\"ae40d2da42dfdbb2\",\"name\":\"Click to run\",\"props\":[{\"p\":\"payload\"},{\"p\":\"topic\",\"vt\":\"str\"}],\"repeat\":\"\",\"crontab\":\"\",\"once\":false,\"onceDelay\":0.1,\"topic\":\"\",\"payloadType\":\"date\",\"x\":180,\"y\":1080,\"wires\":[[\"e4bf6d56a2d1a00f\"]]},{\"id\":\"e4bf6d56a2d1a00f\",\"type\":\"function\",\"z\":\"ae40d2da42dfdbb2\",\"name\":\"Read MAX temperature\",\"func\":\"const HDC2080_I2C = 0x40;\\n\\nconst hdc = i2c.openSync(1);\\nlet r1 = hdc.readByteSync(HDC2080_I2C, 0x05);\\nhdc.closeSync();\\n\\nmsg.payload = (r1 / 256) * 165 - 40.5;\\nreturn msg;\",\"outputs\":1,\"noerr\":0,\"initialize\":\"\",\"finalize\":\"\",\"libs\":[{\"var\":\"i2c\",\"module\":\"i2c-bus\"}],\"x\":390,\"y\":1080,\"wires\":[[\"5f66699f757577b8\"]]},{\"id\":\"5f66699f757577b8\",\"type\":\"debug\",\"z\":\"ae40d2da42dfdbb2\",\"name\":\"Debug flow5\",\"active\":true,\"tosidebar\":true,\"console\":false,\"tostatus\":false,\"complete\":\"payload\",\"targetType\":\"msg\",\"statusVal\":\"\",\"statusType\":\"auto\",\"x\":610,\"y\":1080,\"wires\":[]}] Flow image:","title":"Reading Max temperature"},{"location":"readingmax/#reading-max-humidity","text":"We read the byte from register 0x06 to get the max humidity. const HDC2080_I2C = 0x40; const hdc = i2c.openSync(1); let r1 = hdc.readByteSync(HDC2080_I2C, 0x06); hdc.closeSync(); msg.payload = (r1 / 256) * 100; return msg; Below the flow for you to copy and import to Node-RED. [{\"id\":\"7acf3202ed2f34ac\",\"type\":\"comment\",\"z\":\"ae40d2da42dfdbb2\",\"name\":\"Flow 5 : Read MAX humidity\",\"info\":\"\",\"x\":220,\"y\":1180,\"wires\":[]},{\"id\":\"cd2f739e240a486b\",\"type\":\"inject\",\"z\":\"ae40d2da42dfdbb2\",\"name\":\"Click to run\",\"props\":[{\"p\":\"payload\"},{\"p\":\"topic\",\"vt\":\"str\"}],\"repeat\":\"\",\"crontab\":\"\",\"once\":false,\"onceDelay\":0.1,\"topic\":\"\",\"payloadType\":\"date\",\"x\":180,\"y\":1240,\"wires\":[[\"9ab0e0e884823fc5\"]]},{\"id\":\"9ab0e0e884823fc5\",\"type\":\"function\",\"z\":\"ae40d2da42dfdbb2\",\"name\":\"Read MAX humidity\",\"func\":\"const HDC2080_I2C = 0x40;\\n\\nconst hdc = i2c.openSync(1);\\nlet r1 = hdc.readByteSync(HDC2080_I2C, 0x06);\\nhdc.closeSync();\\n\\nmsg.payload = (r1 / 256) * 100;\\n\\nreturn msg;\",\"outputs\":1,\"noerr\":0,\"initialize\":\"\",\"finalize\":\"\",\"libs\":[{\"var\":\"i2c\",\"module\":\"i2c-bus\"}],\"x\":380,\"y\":1240,\"wires\":[[\"0f5aca8fc8b1f7a2\"]]},{\"id\":\"0f5aca8fc8b1f7a2\",\"type\":\"debug\",\"z\":\"ae40d2da42dfdbb2\",\"name\":\"Debug flow5\",\"active\":true,\"tosidebar\":true,\"console\":false,\"tostatus\":false,\"complete\":\"payload\",\"targetType\":\"msg\",\"statusVal\":\"\",\"statusType\":\"auto\",\"x\":610,\"y\":1240,\"wires\":[]}] Flow image:","title":"Reading Max humidity"},{"location":"readingtemperaturehumidity/","text":"Reading temperature and humidity Reading temperature This code in a function node enable us to read temperature values stored in the registers of the HDC2080. const HDC2080_I2C = 0x40; let hdc = i2c.openSync(1); let r = hdc.readWordSync(HDC2080_I2C, 0x00); hdc.closeSync(); msg.payload = (r / 65536) * 165 - 40.5; return msg; Below the flow for you to copy and import to Node-RED. [{\"id\":\"48d7c05adb4a40de\",\"type\":\"comment\",\"z\":\"ae40d2da42dfdbb2\",\"name\":\"Flow 4 : Read temperature\",\"info\":\"\",\"x\":210,\"y\":700,\"wires\":[]},{\"id\":\"219d5a07b5b3d622\",\"type\":\"inject\",\"z\":\"ae40d2da42dfdbb2\",\"name\":\"Click to run\",\"props\":[{\"p\":\"payload\"},{\"p\":\"topic\",\"vt\":\"str\"}],\"repeat\":\"\",\"crontab\":\"\",\"once\":false,\"onceDelay\":0.1,\"topic\":\"\",\"payloadType\":\"date\",\"x\":180,\"y\":760,\"wires\":[[\"ab3d99f63335f7f8\"]]},{\"id\":\"ab3d99f63335f7f8\",\"type\":\"function\",\"z\":\"ae40d2da42dfdbb2\",\"name\":\"Read temperature\",\"func\":\"const HDC2080_I2C = 0x40;\\n\\nlet hdc = i2c.openSync(1);\\nlet r = hdc.readWordSync(HDC2080_I2C, 0x00);\\nhdc.closeSync();\\n\\nmsg.payload = (r / 65536) * 165 - 40.5;\\n\\nreturn msg;\",\"outputs\":1,\"noerr\":0,\"initialize\":\"\",\"finalize\":\"\",\"libs\":[{\"var\":\"i2c\",\"module\":\"i2c-bus\"}],\"x\":370,\"y\":760,\"wires\":[[\"d3cf046c0705ecb6\"]]},{\"id\":\"d3cf046c0705ecb6\",\"type\":\"debug\",\"z\":\"ae40d2da42dfdbb2\",\"name\":\"Debug flow4\",\"active\":true,\"tosidebar\":true,\"console\":false,\"tostatus\":false,\"complete\":\"payload\",\"targetType\":\"msg\",\"statusVal\":\"\",\"statusType\":\"auto\",\"x\":570,\"y\":760,\"wires\":[]}] Here the look of the flow: When you click the inject node you will get as result a mesurement displayed in the debug panel: Reading humidity This code reads the humidity registers: const HDC2080_I2C = 0x40; let hdc = i2c.openSync(1); let r = hdc.readWordSync(HDC2080_I2C, 0x02); hdc.closeSync(); msg.payload = r / 65536 * 100; return msg; Below the flow for you to copy and import to Node-RED. [{\"id\":\"3c8ea04b57908649\",\"type\":\"inject\",\"z\":\"ae40d2da42dfdbb2\",\"name\":\"Click to run\",\"props\":[{\"p\":\"payload\"},{\"p\":\"topic\",\"vt\":\"str\"}],\"repeat\":\"\",\"crontab\":\"\",\"once\":false,\"onceDelay\":0.1,\"topic\":\"\",\"payloadType\":\"date\",\"x\":180,\"y\":920,\"wires\":[[\"4875a12e866cb662\"]]},{\"id\":\"5e30deb66330b5d9\",\"type\":\"comment\",\"z\":\"ae40d2da42dfdbb2\",\"name\":\"Flow4 : Read Humidity\",\"info\":\"\",\"x\":200,\"y\":860,\"wires\":[]},{\"id\":\"4875a12e866cb662\",\"type\":\"function\",\"z\":\"ae40d2da42dfdbb2\",\"name\":\"Read humidity\",\"func\":\"const HDC2080_I2C = 0x40;\\n\\nlet hdc = i2c.openSync(1);\\nlet r = hdc.readWordSync(HDC2080_I2C, 0x02);\\nhdc.closeSync();\\n\\nmsg.payload = r / 65536 * 100;\\n\\nreturn msg;\",\"outputs\":1,\"noerr\":0,\"initialize\":\"\",\"finalize\":\"\",\"libs\":[{\"var\":\"i2c\",\"module\":\"i2c-bus\"}],\"x\":360,\"y\":920,\"wires\":[[\"1cec6607f73c9622\"]]},{\"id\":\"1cec6607f73c9622\",\"type\":\"debug\",\"z\":\"ae40d2da42dfdbb2\",\"name\":\"Debug flow4\",\"active\":true,\"tosidebar\":true,\"console\":false,\"tostatus\":false,\"complete\":\"payload\",\"targetType\":\"msg\",\"statusVal\":\"\",\"statusType\":\"auto\",\"x\":570,\"y\":920,\"wires\":[]}] and here below the look of the flow: and this is the result in the debug panel: Note We did not bother limiting the number of decimal digits for the measurement. Given the accuracy of the sensor it makes no sense using more than one digit after the decimal point.","title":"Reading temperature and humidity"},{"location":"readingtemperaturehumidity/#reading-temperature-and-humidity","text":"","title":"Reading temperature and humidity"},{"location":"readingtemperaturehumidity/#reading-temperature","text":"This code in a function node enable us to read temperature values stored in the registers of the HDC2080. const HDC2080_I2C = 0x40; let hdc = i2c.openSync(1); let r = hdc.readWordSync(HDC2080_I2C, 0x00); hdc.closeSync(); msg.payload = (r / 65536) * 165 - 40.5; return msg; Below the flow for you to copy and import to Node-RED. [{\"id\":\"48d7c05adb4a40de\",\"type\":\"comment\",\"z\":\"ae40d2da42dfdbb2\",\"name\":\"Flow 4 : Read temperature\",\"info\":\"\",\"x\":210,\"y\":700,\"wires\":[]},{\"id\":\"219d5a07b5b3d622\",\"type\":\"inject\",\"z\":\"ae40d2da42dfdbb2\",\"name\":\"Click to run\",\"props\":[{\"p\":\"payload\"},{\"p\":\"topic\",\"vt\":\"str\"}],\"repeat\":\"\",\"crontab\":\"\",\"once\":false,\"onceDelay\":0.1,\"topic\":\"\",\"payloadType\":\"date\",\"x\":180,\"y\":760,\"wires\":[[\"ab3d99f63335f7f8\"]]},{\"id\":\"ab3d99f63335f7f8\",\"type\":\"function\",\"z\":\"ae40d2da42dfdbb2\",\"name\":\"Read temperature\",\"func\":\"const HDC2080_I2C = 0x40;\\n\\nlet hdc = i2c.openSync(1);\\nlet r = hdc.readWordSync(HDC2080_I2C, 0x00);\\nhdc.closeSync();\\n\\nmsg.payload = (r / 65536) * 165 - 40.5;\\n\\nreturn msg;\",\"outputs\":1,\"noerr\":0,\"initialize\":\"\",\"finalize\":\"\",\"libs\":[{\"var\":\"i2c\",\"module\":\"i2c-bus\"}],\"x\":370,\"y\":760,\"wires\":[[\"d3cf046c0705ecb6\"]]},{\"id\":\"d3cf046c0705ecb6\",\"type\":\"debug\",\"z\":\"ae40d2da42dfdbb2\",\"name\":\"Debug flow4\",\"active\":true,\"tosidebar\":true,\"console\":false,\"tostatus\":false,\"complete\":\"payload\",\"targetType\":\"msg\",\"statusVal\":\"\",\"statusType\":\"auto\",\"x\":570,\"y\":760,\"wires\":[]}] Here the look of the flow: When you click the inject node you will get as result a mesurement displayed in the debug panel:","title":"Reading temperature"},{"location":"readingtemperaturehumidity/#reading-humidity","text":"This code reads the humidity registers: const HDC2080_I2C = 0x40; let hdc = i2c.openSync(1); let r = hdc.readWordSync(HDC2080_I2C, 0x02); hdc.closeSync(); msg.payload = r / 65536 * 100; return msg; Below the flow for you to copy and import to Node-RED. [{\"id\":\"3c8ea04b57908649\",\"type\":\"inject\",\"z\":\"ae40d2da42dfdbb2\",\"name\":\"Click to run\",\"props\":[{\"p\":\"payload\"},{\"p\":\"topic\",\"vt\":\"str\"}],\"repeat\":\"\",\"crontab\":\"\",\"once\":false,\"onceDelay\":0.1,\"topic\":\"\",\"payloadType\":\"date\",\"x\":180,\"y\":920,\"wires\":[[\"4875a12e866cb662\"]]},{\"id\":\"5e30deb66330b5d9\",\"type\":\"comment\",\"z\":\"ae40d2da42dfdbb2\",\"name\":\"Flow4 : Read Humidity\",\"info\":\"\",\"x\":200,\"y\":860,\"wires\":[]},{\"id\":\"4875a12e866cb662\",\"type\":\"function\",\"z\":\"ae40d2da42dfdbb2\",\"name\":\"Read humidity\",\"func\":\"const HDC2080_I2C = 0x40;\\n\\nlet hdc = i2c.openSync(1);\\nlet r = hdc.readWordSync(HDC2080_I2C, 0x02);\\nhdc.closeSync();\\n\\nmsg.payload = r / 65536 * 100;\\n\\nreturn msg;\",\"outputs\":1,\"noerr\":0,\"initialize\":\"\",\"finalize\":\"\",\"libs\":[{\"var\":\"i2c\",\"module\":\"i2c-bus\"}],\"x\":360,\"y\":920,\"wires\":[[\"1cec6607f73c9622\"]]},{\"id\":\"1cec6607f73c9622\",\"type\":\"debug\",\"z\":\"ae40d2da42dfdbb2\",\"name\":\"Debug flow4\",\"active\":true,\"tosidebar\":true,\"console\":false,\"tostatus\":false,\"complete\":\"payload\",\"targetType\":\"msg\",\"statusVal\":\"\",\"statusType\":\"auto\",\"x\":570,\"y\":920,\"wires\":[]}] and here below the look of the flow: and this is the result in the debug panel: Note We did not bother limiting the number of decimal digits for the measurement. Given the accuracy of the sensor it makes no sense using more than one digit after the decimal point.","title":"Reading humidity"},{"location":"registermap/","text":"Register map The flows in this advanced session use Node-RED dashboard to display data in a friendly way. The fist flow gives us an unified view of the status of all registers. This is a handy tool for those developing with the HDC2080. This is how the flow looks like: The view in the dashboard: Note The flow uses a MQTT node. This is a commom way of passing data from sensors to a dashboard.","title":"Register map"},{"location":"registermap/#register-map","text":"The flows in this advanced session use Node-RED dashboard to display data in a friendly way. The fist flow gives us an unified view of the status of all registers. This is a handy tool for those developing with the HDC2080. This is how the flow looks like: The view in the dashboard: Note The flow uses a MQTT node. This is a commom way of passing data from sensors to a dashboard.","title":"Register map"},{"location":"registers/","text":"Register Map Programming and using the HDC2080 is not complicated as long as we understand the register map. There are 20 registers in the device. Most of them are read-only. We will write bytes to few of them to program the behaviour of our device. Table from TI datasheet","title":"Registers"},{"location":"registers/#register-map","text":"Programming and using the HDC2080 is not complicated as long as we understand the register map. There are 20 registers in the device. Most of them are read-only. We will write bytes to few of them to program the behaviour of our device. Table from TI datasheet","title":"Register Map"},{"location":"softreset/","text":"Soft reset Soft reset to clear the maximum values The max values can be reset by powering down - powering up the device or doing a soft reset In order to soft reset the device we need to set the most significant bit of register 0x0E to value one. However the result of this reset is that the other bits of the same register will be set to zero. Danger As a matter of fact everything in the device will reset, including configured thresholds and interrupt configuration. It means we will lose any previous configuration. So, the following code is an example on how to partially save the configuration. A real life code would need to to save all configuration registers before doing a soft reset. Code below shows how to save the configuration register (0x0E) and reset the device: const HDC2080_I2C = 0x40; const hdc = i2c.openSync(1); let r1 = hdc.readByteSync(HDC2080_I2C, 0x0E); hdc.writeByteSync(HDC2080_I2C, 0x0E, 0x80); hdc.closeSync(); const hdc1 = i2c.openSync(1); hdc1.writeByteSync(HDC2080_I2C, 0x0E, r1); hdc1.closeSync(); msg.payload = \"0x\" + r1.toString(16).padStart(2, '0'); return msg; Below the flow for you to copy and import to Node-RED. [{\"id\":\"53fbefa876532be8\",\"type\":\"comment\",\"z\":\"ae40d2da42dfdbb2\",\"name\":\"Flow 6 : Soft reset\",\"info\":\"\",\"x\":190,\"y\":1360,\"wires\":[]},{\"id\":\"aa6dd67bf670c943\",\"type\":\"inject\",\"z\":\"ae40d2da42dfdbb2\",\"name\":\"Click to run\",\"props\":[{\"p\":\"payload\"},{\"p\":\"topic\",\"vt\":\"str\"}],\"repeat\":\"\",\"crontab\":\"\",\"once\":false,\"onceDelay\":0.1,\"topic\":\"\",\"payloadType\":\"date\",\"x\":180,\"y\":1420,\"wires\":[[\"3a16126dc33f9eb1\"]]},{\"id\":\"3a16126dc33f9eb1\",\"type\":\"function\",\"z\":\"ae40d2da42dfdbb2\",\"name\":\"Soft reset\",\"func\":\"const HDC2080_I2C = 0x40;\\n\\nconst hdc = i2c.openSync(1);\\nlet r1 = hdc.readByteSync(HDC2080_I2C, 0x0E);\\nhdc.writeByteSync(HDC2080_I2C, 0x0E, 0x80);\\nhdc.closeSync();\\n\\nconst hdc1 = i2c.openSync(1);\\nhdc1.writeByteSync(HDC2080_I2C, 0x0E, r1);\\nhdc1.closeSync();\\n\\nmsg.payload = \\\"0x\\\" + r1.toString(16).padStart(2, '0');\\nreturn msg;\",\"outputs\":1,\"noerr\":0,\"initialize\":\"\",\"finalize\":\"\",\"libs\":[{\"var\":\"i2c\",\"module\":\"i2c-bus\"}],\"x\":340,\"y\":1420,\"wires\":[[\"9e5323c9ae142a3e\"]]},{\"id\":\"9e5323c9ae142a3e\",\"type\":\"debug\",\"z\":\"ae40d2da42dfdbb2\",\"name\":\"Debug flow6\",\"active\":true,\"tosidebar\":true,\"console\":false,\"tostatus\":false,\"complete\":\"payload\",\"targetType\":\"msg\",\"statusVal\":\"\",\"statusType\":\"auto\",\"x\":510,\"y\":1420,\"wires\":[]}] Flow: Note If you read the maximum temperature and humidity right after a reset, without triggering a new measurement, you will get the values -40.5 for temperatue and 0 for humidity. This is not an issue at all as long as you are fully aware and use the reading in a proper way. Alternatively force a measurement before reading again the max values.","title":"Soft reset"},{"location":"softreset/#soft-reset","text":"","title":"Soft reset"},{"location":"softreset/#soft-reset-to-clear-the-maximum-values","text":"The max values can be reset by powering down - powering up the device or doing a soft reset In order to soft reset the device we need to set the most significant bit of register 0x0E to value one. However the result of this reset is that the other bits of the same register will be set to zero. Danger As a matter of fact everything in the device will reset, including configured thresholds and interrupt configuration. It means we will lose any previous configuration. So, the following code is an example on how to partially save the configuration. A real life code would need to to save all configuration registers before doing a soft reset. Code below shows how to save the configuration register (0x0E) and reset the device: const HDC2080_I2C = 0x40; const hdc = i2c.openSync(1); let r1 = hdc.readByteSync(HDC2080_I2C, 0x0E); hdc.writeByteSync(HDC2080_I2C, 0x0E, 0x80); hdc.closeSync(); const hdc1 = i2c.openSync(1); hdc1.writeByteSync(HDC2080_I2C, 0x0E, r1); hdc1.closeSync(); msg.payload = \"0x\" + r1.toString(16).padStart(2, '0'); return msg; Below the flow for you to copy and import to Node-RED. [{\"id\":\"53fbefa876532be8\",\"type\":\"comment\",\"z\":\"ae40d2da42dfdbb2\",\"name\":\"Flow 6 : Soft reset\",\"info\":\"\",\"x\":190,\"y\":1360,\"wires\":[]},{\"id\":\"aa6dd67bf670c943\",\"type\":\"inject\",\"z\":\"ae40d2da42dfdbb2\",\"name\":\"Click to run\",\"props\":[{\"p\":\"payload\"},{\"p\":\"topic\",\"vt\":\"str\"}],\"repeat\":\"\",\"crontab\":\"\",\"once\":false,\"onceDelay\":0.1,\"topic\":\"\",\"payloadType\":\"date\",\"x\":180,\"y\":1420,\"wires\":[[\"3a16126dc33f9eb1\"]]},{\"id\":\"3a16126dc33f9eb1\",\"type\":\"function\",\"z\":\"ae40d2da42dfdbb2\",\"name\":\"Soft reset\",\"func\":\"const HDC2080_I2C = 0x40;\\n\\nconst hdc = i2c.openSync(1);\\nlet r1 = hdc.readByteSync(HDC2080_I2C, 0x0E);\\nhdc.writeByteSync(HDC2080_I2C, 0x0E, 0x80);\\nhdc.closeSync();\\n\\nconst hdc1 = i2c.openSync(1);\\nhdc1.writeByteSync(HDC2080_I2C, 0x0E, r1);\\nhdc1.closeSync();\\n\\nmsg.payload = \\\"0x\\\" + r1.toString(16).padStart(2, '0');\\nreturn msg;\",\"outputs\":1,\"noerr\":0,\"initialize\":\"\",\"finalize\":\"\",\"libs\":[{\"var\":\"i2c\",\"module\":\"i2c-bus\"}],\"x\":340,\"y\":1420,\"wires\":[[\"9e5323c9ae142a3e\"]]},{\"id\":\"9e5323c9ae142a3e\",\"type\":\"debug\",\"z\":\"ae40d2da42dfdbb2\",\"name\":\"Debug flow6\",\"active\":true,\"tosidebar\":true,\"console\":false,\"tostatus\":false,\"complete\":\"payload\",\"targetType\":\"msg\",\"statusVal\":\"\",\"statusType\":\"auto\",\"x\":510,\"y\":1420,\"wires\":[]}] Flow: Note If you read the maximum temperature and humidity right after a reset, without triggering a new measurement, you will get the values -40.5 for temperatue and 0 for humidity. This is not an issue at all as long as you are fully aware and use the reading in a proper way. Alternatively force a measurement before reading again the max values.","title":"Soft reset to clear the maximum values"},{"location":"thresholds/","text":"Thresholds What is the threshold features It is possible to program the sensor to trigger an interruption when the temperature or humidity reaches a value too high or too low. These maximum and minimum values (thresholds) are configurable. There are four registers that can be programmed to store them. This feature can be useful in a number of use cases.","title":"Thresholds"},{"location":"thresholds/#thresholds","text":"","title":"Thresholds"},{"location":"thresholds/#what-is-the-threshold-features","text":"It is possible to program the sensor to trigger an interruption when the temperature or humidity reaches a value too high or too low. These maximum and minimum values (thresholds) are configurable. There are four registers that can be programmed to store them. This feature can be useful in a number of use cases.","title":"What is the threshold features"},{"location":"triggeringmeasurements/","text":"Triggering measurements via I2C Using the register 0x0F In the previous session we programmed the device disabling the auto measurement mode. Let\u00b4s see now how to trigger a measurement. It\u00b4s not complicated at all. All we need to do is write the byte 0x01 to the register 0x0F. const HDC2080_I2C = 0x40; const hdc = i2c.openSync(1); hdc.writeByteSync(HDC2080_I2C, 0x0F, 0x01); hdc.closeSync(); msg.payload = \"Measurement triggered\"; return msg; Below the flow for you to copy and import to Node-RED. [{\"id\":\"45db449f2dcf4ce1\",\"type\":\"comment\",\"z\":\"ae40d2da42dfdbb2\",\"name\":\"Flow 3 : Trigger measurement via I2C\",\"info\":\"\",\"x\":250,\"y\":540,\"wires\":[]},{\"id\":\"4635f68954c0b4f8\",\"type\":\"inject\",\"z\":\"ae40d2da42dfdbb2\",\"name\":\"Click to run\",\"props\":[{\"p\":\"payload\"},{\"p\":\"topic\",\"vt\":\"str\"}],\"repeat\":\"\",\"crontab\":\"\",\"once\":false,\"onceDelay\":0.1,\"topic\":\"\",\"payloadType\":\"date\",\"x\":180,\"y\":600,\"wires\":[[\"c6c3eb7076945329\"]]},{\"id\":\"c6c3eb7076945329\",\"type\":\"function\",\"z\":\"ae40d2da42dfdbb2\",\"name\":\"Trigger measurement\",\"func\":\"const HDC2080_I2C = 0x40;\\n\\nconst hdc = i2c.openSync(1);\\nhdc.writeByteSync(HDC2080_I2C, 0x0F, 0x01);\\nhdc.closeSync();\\n\\nmsg.payload = \\\"Measurement triggered\\\";\\n\\nreturn msg;\",\"outputs\":1,\"noerr\":0,\"initialize\":\"\",\"finalize\":\"\",\"libs\":[{\"var\":\"i2c\",\"module\":\"i2c-bus\"}],\"x\":410,\"y\":600,\"wires\":[[\"133fd4465ffca89a\"]]},{\"id\":\"133fd4465ffca89a\",\"type\":\"debug\",\"z\":\"ae40d2da42dfdbb2\",\"name\":\"Debug flow3\",\"active\":true,\"tosidebar\":true,\"console\":false,\"tostatus\":false,\"complete\":\"payload\",\"targetType\":\"msg\",\"statusVal\":\"\",\"statusType\":\"auto\",\"x\":650,\"y\":600,\"wires\":[]}] This is how the flow looks like: You will see only a notification in the debug panel but rest assured that values have been written to the internal registers. We will learn how to grab these values in the next session.","title":"Triggering measurements"},{"location":"triggeringmeasurements/#triggering-measurements-via-i2c","text":"","title":"Triggering measurements via I2C"},{"location":"triggeringmeasurements/#using-the-register-0x0f","text":"In the previous session we programmed the device disabling the auto measurement mode. Let\u00b4s see now how to trigger a measurement. It\u00b4s not complicated at all. All we need to do is write the byte 0x01 to the register 0x0F. const HDC2080_I2C = 0x40; const hdc = i2c.openSync(1); hdc.writeByteSync(HDC2080_I2C, 0x0F, 0x01); hdc.closeSync(); msg.payload = \"Measurement triggered\"; return msg; Below the flow for you to copy and import to Node-RED. [{\"id\":\"45db449f2dcf4ce1\",\"type\":\"comment\",\"z\":\"ae40d2da42dfdbb2\",\"name\":\"Flow 3 : Trigger measurement via I2C\",\"info\":\"\",\"x\":250,\"y\":540,\"wires\":[]},{\"id\":\"4635f68954c0b4f8\",\"type\":\"inject\",\"z\":\"ae40d2da42dfdbb2\",\"name\":\"Click to run\",\"props\":[{\"p\":\"payload\"},{\"p\":\"topic\",\"vt\":\"str\"}],\"repeat\":\"\",\"crontab\":\"\",\"once\":false,\"onceDelay\":0.1,\"topic\":\"\",\"payloadType\":\"date\",\"x\":180,\"y\":600,\"wires\":[[\"c6c3eb7076945329\"]]},{\"id\":\"c6c3eb7076945329\",\"type\":\"function\",\"z\":\"ae40d2da42dfdbb2\",\"name\":\"Trigger measurement\",\"func\":\"const HDC2080_I2C = 0x40;\\n\\nconst hdc = i2c.openSync(1);\\nhdc.writeByteSync(HDC2080_I2C, 0x0F, 0x01);\\nhdc.closeSync();\\n\\nmsg.payload = \\\"Measurement triggered\\\";\\n\\nreturn msg;\",\"outputs\":1,\"noerr\":0,\"initialize\":\"\",\"finalize\":\"\",\"libs\":[{\"var\":\"i2c\",\"module\":\"i2c-bus\"}],\"x\":410,\"y\":600,\"wires\":[[\"133fd4465ffca89a\"]]},{\"id\":\"133fd4465ffca89a\",\"type\":\"debug\",\"z\":\"ae40d2da42dfdbb2\",\"name\":\"Debug flow3\",\"active\":true,\"tosidebar\":true,\"console\":false,\"tostatus\":false,\"complete\":\"payload\",\"targetType\":\"msg\",\"statusVal\":\"\",\"statusType\":\"auto\",\"x\":650,\"y\":600,\"wires\":[]}] This is how the flow looks like: You will see only a notification in the debug panel but rest assured that values have been written to the internal registers. We will learn how to grab these values in the next session.","title":"Using the register 0x0F"},{"location":"writeconfigurationregister/","text":"Programming the configuration register Before we can read temperature and humidity we have to program the device behaviour. In this example we will program the sensor with the auto measurement disabled. In this mode of operation you have to trigger the reading via I2C commands. So, let's see how to read and write to the configuration register 0x0E. So, let\u00b4s see how to read and write to the configuration register 0x0E. Reading the configuration register A single function node with below code will do the magic: const HDC2080_I2C = 0x40; const hdc = i2c.openSync(1); let r1 = hdc.readByteSync(HDC2080_I2C, 0x0E); hdc.closeSync(); msg.payload = \"0x\" + r1.toString(16).padStart(2, '0'); return msg; This code will open the I2C bus, read the value (8-bits) from register 0x0E and will close the bus. The result will be formated as a hexadecimal string and stored in msg.payload. Below the flow for you to copy and import to Node-RED. [{\"id\":\"24d24b3f86e7d89a\",\"type\":\"function\",\"z\":\"ae40d2da42dfdbb2\",\"name\":\"Read configuration register\",\"func\":\"const HDC2080_I2C = 0x40;\\n\\nconst hdc = i2c.openSync(1);\\nlet r1 = hdc.readByteSync(HDC2080_I2C, 0x0E);\\nhdc.closeSync();\\n\\nmsg.payload = \\\"0x\\\" + r1.toString(16).padStart(2, '0');\\nreturn msg;\",\"outputs\":1,\"noerr\":0,\"initialize\":\"\",\"finalize\":\"\",\"libs\":[{\"var\":\"i2c\",\"module\":\"i2c-bus\"}],\"x\":420,\"y\":300,\"wires\":[[\"38ef03979f20bbe2\"]]},{\"id\":\"18e008a64c8ea4be\",\"type\":\"inject\",\"z\":\"ae40d2da42dfdbb2\",\"name\":\"Click to run\",\"props\":[{\"p\":\"payload\"},{\"p\":\"topic\",\"vt\":\"str\"}],\"repeat\":\"\",\"crontab\":\"\",\"once\":false,\"onceDelay\":0.1,\"topic\":\"\",\"payloadType\":\"date\",\"x\":180,\"y\":300,\"wires\":[[\"24d24b3f86e7d89a\"]]},{\"id\":\"e0fb19b67f1d56fd\",\"type\":\"comment\",\"z\":\"ae40d2da42dfdbb2\",\"name\":\"Flow 2 : Read configuration register 0xE0\",\"info\":\"\",\"x\":260,\"y\":240,\"wires\":[]},{\"id\":\"38ef03979f20bbe2\",\"type\":\"debug\",\"z\":\"ae40d2da42dfdbb2\",\"name\":\"Debug flow2\",\"active\":true,\"tosidebar\":true,\"console\":false,\"tostatus\":true,\"complete\":\"payload\",\"targetType\":\"msg\",\"statusVal\":\"payload\",\"statusType\":\"auto\",\"x\":650,\"y\":300,\"wires\":[]}] and below what I got in the debug panel. When you run this flow for the first time sure enough you will see a different value. Writing to the configuration register We want to disable the auto measurement mode. For that purpose we have to write the value 0x06 to the configuration register. The code is straightforward: const HDC2080_I2C = 0x40; const hdc = i2c.openSync(1); hdc.writeByteSync(HDC2080_I2C, 0x0E, 0x06); hdc.closeSync(); msg.payload = \"0x06\"; return msg; Below the flow for you to copy and import to Node-RED. [{\"id\":\"2fce20d60bba3448\",\"type\":\"comment\",\"z\":\"ae40d2da42dfdbb2\",\"name\":\"Flow 2 : Write configuration register 0x0E\",\"info\":\"\",\"x\":260,\"y\":380,\"wires\":[]},{\"id\":\"3baa31a1db1fb78d\",\"type\":\"inject\",\"z\":\"ae40d2da42dfdbb2\",\"name\":\"Click to run\",\"props\":[{\"p\":\"payload\"},{\"p\":\"topic\",\"vt\":\"str\"}],\"repeat\":\"\",\"crontab\":\"\",\"once\":false,\"onceDelay\":0.1,\"topic\":\"\",\"payloadType\":\"date\",\"x\":180,\"y\":440,\"wires\":[[\"3be881cfad1c8e09\"]]},{\"id\":\"3be881cfad1c8e09\",\"type\":\"function\",\"z\":\"ae40d2da42dfdbb2\",\"name\":\"Write configuration register\",\"func\":\"const HDC2080_I2C = 0x40;\\n\\nconst hdc = i2c.openSync(1);\\nhdc.writeByteSync(HDC2080_I2C, 0x0E, 0x06);\\nhdc.closeSync();\\n\\nmsg.payload = \\\"0x06\\\";\\nreturn msg;\",\"outputs\":1,\"noerr\":0,\"initialize\":\"\",\"finalize\":\"\",\"libs\":[{\"var\":\"i2c\",\"module\":\"i2c-bus\"}],\"x\":420,\"y\":440,\"wires\":[[\"322d01ab7757eba2\"]]},{\"id\":\"322d01ab7757eba2\",\"type\":\"debug\",\"z\":\"ae40d2da42dfdbb2\",\"name\":\"Debug flow2\",\"active\":true,\"tosidebar\":true,\"console\":false,\"tostatus\":false,\"complete\":\"payload\",\"targetType\":\"msg\",\"statusVal\":\"\",\"statusType\":\"auto\",\"x\":650,\"y\":440,\"wires\":[]}] Below what the flow looks like: If you want to assure the value was correctly stored in the register you can run again the flow that reads the value from the register. There will be no surprises here.","title":"Program the configuration register"},{"location":"writeconfigurationregister/#programming-the-configuration-register","text":"Before we can read temperature and humidity we have to program the device behaviour. In this example we will program the sensor with the auto measurement disabled. In this mode of operation you have to trigger the reading via I2C commands. So, let's see how to read and write to the configuration register 0x0E. So, let\u00b4s see how to read and write to the configuration register 0x0E.","title":"Programming the configuration register"},{"location":"writeconfigurationregister/#reading-the-configuration-register","text":"A single function node with below code will do the magic: const HDC2080_I2C = 0x40; const hdc = i2c.openSync(1); let r1 = hdc.readByteSync(HDC2080_I2C, 0x0E); hdc.closeSync(); msg.payload = \"0x\" + r1.toString(16).padStart(2, '0'); return msg; This code will open the I2C bus, read the value (8-bits) from register 0x0E and will close the bus. The result will be formated as a hexadecimal string and stored in msg.payload. Below the flow for you to copy and import to Node-RED. [{\"id\":\"24d24b3f86e7d89a\",\"type\":\"function\",\"z\":\"ae40d2da42dfdbb2\",\"name\":\"Read configuration register\",\"func\":\"const HDC2080_I2C = 0x40;\\n\\nconst hdc = i2c.openSync(1);\\nlet r1 = hdc.readByteSync(HDC2080_I2C, 0x0E);\\nhdc.closeSync();\\n\\nmsg.payload = \\\"0x\\\" + r1.toString(16).padStart(2, '0');\\nreturn msg;\",\"outputs\":1,\"noerr\":0,\"initialize\":\"\",\"finalize\":\"\",\"libs\":[{\"var\":\"i2c\",\"module\":\"i2c-bus\"}],\"x\":420,\"y\":300,\"wires\":[[\"38ef03979f20bbe2\"]]},{\"id\":\"18e008a64c8ea4be\",\"type\":\"inject\",\"z\":\"ae40d2da42dfdbb2\",\"name\":\"Click to run\",\"props\":[{\"p\":\"payload\"},{\"p\":\"topic\",\"vt\":\"str\"}],\"repeat\":\"\",\"crontab\":\"\",\"once\":false,\"onceDelay\":0.1,\"topic\":\"\",\"payloadType\":\"date\",\"x\":180,\"y\":300,\"wires\":[[\"24d24b3f86e7d89a\"]]},{\"id\":\"e0fb19b67f1d56fd\",\"type\":\"comment\",\"z\":\"ae40d2da42dfdbb2\",\"name\":\"Flow 2 : Read configuration register 0xE0\",\"info\":\"\",\"x\":260,\"y\":240,\"wires\":[]},{\"id\":\"38ef03979f20bbe2\",\"type\":\"debug\",\"z\":\"ae40d2da42dfdbb2\",\"name\":\"Debug flow2\",\"active\":true,\"tosidebar\":true,\"console\":false,\"tostatus\":true,\"complete\":\"payload\",\"targetType\":\"msg\",\"statusVal\":\"payload\",\"statusType\":\"auto\",\"x\":650,\"y\":300,\"wires\":[]}] and below what I got in the debug panel. When you run this flow for the first time sure enough you will see a different value.","title":"Reading the configuration register"},{"location":"writeconfigurationregister/#writing-to-the-configuration-register","text":"We want to disable the auto measurement mode. For that purpose we have to write the value 0x06 to the configuration register. The code is straightforward: const HDC2080_I2C = 0x40; const hdc = i2c.openSync(1); hdc.writeByteSync(HDC2080_I2C, 0x0E, 0x06); hdc.closeSync(); msg.payload = \"0x06\"; return msg; Below the flow for you to copy and import to Node-RED. [{\"id\":\"2fce20d60bba3448\",\"type\":\"comment\",\"z\":\"ae40d2da42dfdbb2\",\"name\":\"Flow 2 : Write configuration register 0x0E\",\"info\":\"\",\"x\":260,\"y\":380,\"wires\":[]},{\"id\":\"3baa31a1db1fb78d\",\"type\":\"inject\",\"z\":\"ae40d2da42dfdbb2\",\"name\":\"Click to run\",\"props\":[{\"p\":\"payload\"},{\"p\":\"topic\",\"vt\":\"str\"}],\"repeat\":\"\",\"crontab\":\"\",\"once\":false,\"onceDelay\":0.1,\"topic\":\"\",\"payloadType\":\"date\",\"x\":180,\"y\":440,\"wires\":[[\"3be881cfad1c8e09\"]]},{\"id\":\"3be881cfad1c8e09\",\"type\":\"function\",\"z\":\"ae40d2da42dfdbb2\",\"name\":\"Write configuration register\",\"func\":\"const HDC2080_I2C = 0x40;\\n\\nconst hdc = i2c.openSync(1);\\nhdc.writeByteSync(HDC2080_I2C, 0x0E, 0x06);\\nhdc.closeSync();\\n\\nmsg.payload = \\\"0x06\\\";\\nreturn msg;\",\"outputs\":1,\"noerr\":0,\"initialize\":\"\",\"finalize\":\"\",\"libs\":[{\"var\":\"i2c\",\"module\":\"i2c-bus\"}],\"x\":420,\"y\":440,\"wires\":[[\"322d01ab7757eba2\"]]},{\"id\":\"322d01ab7757eba2\",\"type\":\"debug\",\"z\":\"ae40d2da42dfdbb2\",\"name\":\"Debug flow2\",\"active\":true,\"tosidebar\":true,\"console\":false,\"tostatus\":false,\"complete\":\"payload\",\"targetType\":\"msg\",\"statusVal\":\"\",\"statusType\":\"auto\",\"x\":650,\"y\":440,\"wires\":[]}] Below what the flow looks like: If you want to assure the value was correctly stored in the register you can run again the flow that reads the value from the register. There will be no surprises here.","title":"Writing to the configuration register"}]}